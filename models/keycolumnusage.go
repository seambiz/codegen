// Package db contains the types for schema 'information_schema'.
package models

import (
	"database/sql"
	"io"
	"math/big"

	"bitbucket.org/codegen/convert"
	"bitbucket.org/seambiz/buffer"
	"bitbucket.org/seambiz/sdb"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

// GENERATED BY CODEGEN. DO NOT EDIT.
// constant slice for all fields of the table.
// nolint[gochecknoglobals]
var keycolumnusageQueryFieldsAll = []string{"constraint_catalog", "constraint_schema", "constraint_name", "table_catalog", "table_schema", "table_name", "column_name", "ordinal_position", "position_in_unique_constraint", "referenced_table_schema", "referenced_table_name", "referenced_column_name"}

// returns fields, that should be used.
// nolint[gocyclo]
func KeyColumnUsageQueryFields(colSet *big.Int) []string {
	if colSet == nil {
		return keycolumnusageQueryFieldsAll
	}

	fields := []string{}
	if colSet.Bit(KeyColumnUsageConstraintCatalog) == 1 {
		fields = append(fields, "constraint_catalog")
	}
	if colSet.Bit(KeyColumnUsageConstraintSchema) == 1 {
		fields = append(fields, "constraint_schema")
	}
	if colSet.Bit(KeyColumnUsageConstraintName) == 1 {
		fields = append(fields, "constraint_name")
	}
	if colSet.Bit(KeyColumnUsageTableCatalog) == 1 {
		fields = append(fields, "table_catalog")
	}
	if colSet.Bit(KeyColumnUsageTableSchema) == 1 {
		fields = append(fields, "table_schema")
	}
	if colSet.Bit(KeyColumnUsageTableName) == 1 {
		fields = append(fields, "table_name")
	}
	if colSet.Bit(KeyColumnUsageColumnName) == 1 {
		fields = append(fields, "column_name")
	}
	if colSet.Bit(KeyColumnUsageOrdinalPosition) == 1 {
		fields = append(fields, "ordinal_position")
	}
	if colSet.Bit(KeyColumnUsagePositionInUniqueConstraint) == 1 {
		fields = append(fields, "position_in_unique_constraint")
	}
	if colSet.Bit(KeyColumnUsageReferencedTableSchema) == 1 {
		fields = append(fields, "referenced_table_schema")
	}
	if colSet.Bit(KeyColumnUsageReferencedTableName) == 1 {
		fields = append(fields, "referenced_table_name")
	}
	if colSet.Bit(KeyColumnUsageReferencedColumnName) == 1 {
		fields = append(fields, "referenced_column_name")
	}
	return fields
}

// KeyColumnUsage represents a row from 'information_schema.KEY_COLUMN_USAGE'.
type KeyColumnUsage struct {
	ConstraintCatalog          string `json:"CONSTRAINT_CATALOG" db:"constraint_catalog"`
	ConstraintSchema           string `json:"CONSTRAINT_SCHEMA" db:"constraint_schema"`
	ConstraintName             string `json:"CONSTRAINT_NAME" db:"constraint_name"`
	TableCatalog               string `json:"TABLE_CATALOG" db:"table_catalog"`
	TableSchema                string `json:"TABLE_SCHEMA" db:"table_schema"`
	TableName                  string `json:"TABLE_NAME" db:"table_name"`
	ColumnName                 string `json:"COLUMN_NAME" db:"column_name"`
	OrdinalPosition            int64  `json:"ORDINAL_POSITION" db:"ordinal_position"`
	PositionInUniqueConstraint int64  `json:"POSITION_IN_UNIQUE_CONSTRAINT" db:"position_in_unique_constraint"`
	ReferencedTableSchema      string `json:"REFERENCED_TABLE_SCHEMA" db:"referenced_table_schema"`
	ReferencedTableName        string `json:"REFERENCED_TABLE_NAME" db:"referenced_table_name"`
	ReferencedColumnName       string `json:"REFERENCED_COLUMN_NAME" db:"referenced_column_name"`
}

// new implements DTO.new
func (ke *KeyColumnUsage) new() DTO {
	return &KeyColumnUsage{}
}

// helper struct for common query operations.
type KeyColumnUsageSlice struct {
	data []*KeyColumnUsage
}

// append implements DTOSlice.append
func (ke *KeyColumnUsageSlice) append(d DTO) {
	ke.data = append(ke.data, d.(*KeyColumnUsage))
}

// Columns to be used for various statements.
func (ke *KeyColumnUsageStore) Columns(cols ...int) *KeyColumnUsageStore {
	ke.colSet = big.NewInt(0)
	for _, col := range cols {
		ke.colSet.SetBit(ke.colSet, col, 1)
	}
	return ke
}

// IsEmpty checks if primary key fields are zero.
func (ke *KeyColumnUsage) IsEmpty() bool {
	return true
}

// KeyColumnUsageStore is used to query for 'KeyColumnUsage' records.
type KeyColumnUsageStore struct {
	Store
}

// NewKeyColumnUsageStore return DAO Store for KeyColumnUsage
func NewKeyColumnUsageStore(conn *sql.DB) *KeyColumnUsageStore {
	ke := &KeyColumnUsageStore{}
	ke.db = conn
	ke.withJoin = true
	ke.joinType = sdb.LEFT
	ke.batch = 1000
	return ke
}

// WithoutJoins won't execute JOIN when querying for records.
func (ke *KeyColumnUsageStore) WithoutJoins() *KeyColumnUsageStore {
	ke.withJoin = false
	return ke
}

// Where sets local sql, that will be appended to SELECT.
func (ke *KeyColumnUsageStore) Where(sql string) *KeyColumnUsageStore {
	ke.where = sql
	return ke
}

// OrderBy sets local sql, that will be appended to SELECT.
func (ke *KeyColumnUsageStore) OrderBy(sql string) *KeyColumnUsageStore {
	ke.orderBy = sql
	return ke
}

// GroupBy sets local sql, that will be appended to SELECT.
func (ke *KeyColumnUsageStore) GroupBy(sql string) *KeyColumnUsageStore {
	ke.groupBy = sql
	return ke
}

// Limit result set size
func (ke *KeyColumnUsageStore) Limit(n int) *KeyColumnUsageStore {
	ke.limit = n
	return ke
}

// Offset used, if a limit is provided
func (ke *KeyColumnUsageStore) Offset(n int) *KeyColumnUsageStore {
	ke.offset = n
	return ke
}

// JoinType sets join statement type (Default: INNER | LEFT | RIGHT | OUTER).
func (ke *KeyColumnUsageStore) JoinType(jt string) *KeyColumnUsageStore {
	ke.joinType = jt
	return ke
}

// nolint[gocyclo]
func (ke *KeyColumnUsage) bind(row []sql.RawBytes, withJoin bool, colSet *big.Int, col *int) {
	if colSet == nil || colSet.Bit(KeyColumnUsageConstraintCatalog) == 1 {
		ke.ConstraintCatalog = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageConstraintSchema) == 1 {
		ke.ConstraintSchema = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageConstraintName) == 1 {
		ke.ConstraintName = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageTableCatalog) == 1 {
		ke.TableCatalog = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageTableSchema) == 1 {
		ke.TableSchema = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageTableName) == 1 {
		ke.TableName = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageColumnName) == 1 {
		ke.ColumnName = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageOrdinalPosition) == 1 {
		ke.OrdinalPosition = convert.ToInt64(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsagePositionInUniqueConstraint) == 1 {
		ke.PositionInUniqueConstraint = convert.ToInt64(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageReferencedTableSchema) == 1 {
		ke.ReferencedTableSchema = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageReferencedTableName) == 1 {
		ke.ReferencedTableName = convert.ToString(row[*col])
		*col++
	}
	if colSet == nil || colSet.Bit(KeyColumnUsageReferencedColumnName) == 1 {
		ke.ReferencedColumnName = convert.ToString(row[*col])
		*col++
	}
}
func (ke *KeyColumnUsageStore) selectStatement() *SQLStatement {
	sql := NewSQLStatement()
	sql.Append("SELECT")
	sql.Fields("", "A", KeyColumnUsageQueryFields(ke.colSet))
	sql.Append("FROM information_schema.KEY_COLUMN_USAGE A")
	if ke.where != "" {
		sql.Append("WHERE", ke.where)
	}
	if ke.groupBy != "" {
		sql.Append("GROUP BY", ke.groupBy)
	}
	if ke.orderBy != "" {
		sql.Append("ORDER BY", ke.orderBy)
	}
	if ke.limit > 0 {
		sql.AppendRaw("LIMIT ", ke.limit)
		if ke.offset > 0 {
			sql.AppendRaw(",", ke.offset)
		}
	}
	return sql
}

// One retrieves a row from 'information_schema.KEY_COLUMN_USAGE' as a KeyColumnUsage with possible joined data.
func (ke *KeyColumnUsageStore) One(args ...interface{}) (*KeyColumnUsage, error) {
	data := &KeyColumnUsage{}

	err := ke.one(data, ke.selectStatement(), args...)
	if err != nil {
		log.Error().Err(err).Msg("query one")
		return nil, err
	}
	return data, nil
}

// Query retrieves many rows from 'information_schema.KEY_COLUMN_USAGE' as a slice of KeyColumnUsage with possible joined data.
func (ke *KeyColumnUsageStore) Query(args ...interface{}) ([]*KeyColumnUsage, error) {
	stmt := ke.selectStatement()
	return ke.QueryCustom(stmt.Query(), args...)
}

// QueryCustom retrieves many rows from 'information_schema.KEY_COLUMN_USAGE' as a slice of KeyColumnUsage with possible joined data.
func (ke *KeyColumnUsageStore) QueryCustom(stmt string, args ...interface{}) ([]*KeyColumnUsage, error) {
	dto := &KeyColumnUsage{}
	data := &KeyColumnUsageSlice{}
	err := ke.queryCustom(data, dto, stmt, args...)
	if err != nil {
		log.Error().Err(err).Msg("querycustom")
		return nil, err
	}
	return data.data, nil
}

// keyColumnUsageUpsertStmt helper for generating Upserts general statement
// nolint[gocyclo]
func (ke *KeyColumnUsageStore) keyColumnUsageUpsertStmt() *sdb.UpsertStatement {
	upsert := []string{}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintCatalog) == 1 {
		upsert = append(upsert, "CONSTRAINT_CATALOG = VALUES(CONSTRAINT_CATALOG)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintSchema) == 1 {
		upsert = append(upsert, "CONSTRAINT_SCHEMA = VALUES(CONSTRAINT_SCHEMA)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintName) == 1 {
		upsert = append(upsert, "CONSTRAINT_NAME = VALUES(CONSTRAINT_NAME)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableCatalog) == 1 {
		upsert = append(upsert, "TABLE_CATALOG = VALUES(TABLE_CATALOG)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableSchema) == 1 {
		upsert = append(upsert, "TABLE_SCHEMA = VALUES(TABLE_SCHEMA)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableName) == 1 {
		upsert = append(upsert, "TABLE_NAME = VALUES(TABLE_NAME)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageColumnName) == 1 {
		upsert = append(upsert, "COLUMN_NAME = VALUES(COLUMN_NAME)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageOrdinalPosition) == 1 {
		upsert = append(upsert, "ORDINAL_POSITION = VALUES(ORDINAL_POSITION)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsagePositionInUniqueConstraint) == 1 {
		upsert = append(upsert, "POSITION_IN_UNIQUE_CONSTRAINT = VALUES(POSITION_IN_UNIQUE_CONSTRAINT)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedTableSchema) == 1 {
		upsert = append(upsert, "REFERENCED_TABLE_SCHEMA = VALUES(REFERENCED_TABLE_SCHEMA)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedTableName) == 1 {
		upsert = append(upsert, "REFERENCED_TABLE_NAME = VALUES(REFERENCED_TABLE_NAME)")
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedColumnName) == 1 {
		upsert = append(upsert, "REFERENCED_COLUMN_NAME = VALUES(REFERENCED_COLUMN_NAME)")
	}
	sql := &sdb.UpsertStatement{}
	sql.InsertInto("information_schema.KEY_COLUMN_USAGE")
	sql.Columns("constraint_catalog", "constraint_schema", "constraint_name", "table_catalog", "table_schema", "table_name", "column_name", "ordinal_position", "position_in_unique_constraint", "referenced_table_schema", "referenced_table_name", "referenced_column_name")
	sql.OnDuplicateKeyUpdate(upsert)
	return sql
}

// UpsertOne inserts the KeyColumnUsage to the database.
func (ke *KeyColumnUsageStore) UpsertOne(data *KeyColumnUsage) (int64, error) {
	return ke.Upsert([]*KeyColumnUsage{data})
}

// Upsert executes upsert for array of KeyColumnUsage
func (ke *KeyColumnUsageStore) Upsert(data []*KeyColumnUsage) (int64, error) {
	sql := ke.keyColumnUsageUpsertStmt()

	for _, d := range data {
		sql.Record(d)
	}

	if zerolog.GlobalLevel() == zerolog.DebugLevel {
		log.Debug().Str("fn", "KeyColumnUsageUpsert").Str("stmt", sql.String()).Msg("sql")
	}
	res, err := ke.db.Exec(sql.Query())
	if err != nil {
		log.Error().Err(err).Msg("exec")
		return -1, err
	}
	affected, err := res.RowsAffected()
	if err != nil {
		log.Error().Err(err).Msg("rowsaffected")
		return -1, err
	}

	return affected, nil
}

// Insert inserts the KeyColumnUsage to the database.
func (ke *KeyColumnUsageStore) Insert(data *KeyColumnUsage) error {
	var err error
	sql := NewSQLStatement()
	sql.Append("INSERT INTO information_schema.KEY_COLUMN_USAGE (")
	fields := KeyColumnUsageQueryFields(ke.colSet)
	sql.Fields("", "", fields)
	sql.Append(") VALUES (")
	for i := range fields {
		if i > 0 {
			sql.Append(",")
		}
		sql.Append("?")
	}
	sql.Append(")")

	if zerolog.GlobalLevel() == zerolog.DebugLevel {
		log.Debug().Str("fn", "information_schema.KEY_COLUMN_USAGE.Insert").Str("stmt", sql.String()).Str("ConstraintCatalog", data.ConstraintCatalog).Str("ConstraintSchema", data.ConstraintSchema).Str("ConstraintName", data.ConstraintName).Str("TableCatalog", data.TableCatalog).Str("TableSchema", data.TableSchema).Str("TableName", data.TableName).Str("ColumnName", data.ColumnName).Int64("OrdinalPosition", data.OrdinalPosition).Int64("PositionInUniqueConstraint", data.PositionInUniqueConstraint).Str("ReferencedTableSchema", data.ReferencedTableSchema).Str("ReferencedTableName", data.ReferencedTableName).Str("ReferencedColumnName", data.ReferencedColumnName).Msg("sql")
	}
	_, err = ke.db.Exec(sql.Query(), data.ConstraintCatalog, data.ConstraintSchema, data.ConstraintName, data.TableCatalog, data.TableSchema, data.TableName, data.ColumnName, data.OrdinalPosition, data.PositionInUniqueConstraint, data.ReferencedTableSchema, data.ReferencedTableName, data.ReferencedColumnName)
	if err != nil {
		log.Error().Err(err).Msg("exec")
		return err
	}
	return nil
}

// Update updates the KeyColumnUsage in the database.
// nolint[gocyclo]
func (ke *KeyColumnUsageStore) Update(data *KeyColumnUsage) (int64, error) {
	sql := NewSQLStatement()
	var prepend string
	args := []interface{}{}
	sql.Append("UPDATE information_schema.KEY_COLUMN_USAGE SET")
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintCatalog) == 1 {
		sql.AppendRaw(prepend, "CONSTRAINT_CATALOG = ?")
		prepend = ","
		args = append(args, data.ConstraintCatalog)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintSchema) == 1 {
		sql.AppendRaw(prepend, "CONSTRAINT_SCHEMA = ?")
		prepend = ","
		args = append(args, data.ConstraintSchema)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintName) == 1 {
		sql.AppendRaw(prepend, "CONSTRAINT_NAME = ?")
		prepend = ","
		args = append(args, data.ConstraintName)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableCatalog) == 1 {
		sql.AppendRaw(prepend, "TABLE_CATALOG = ?")
		prepend = ","
		args = append(args, data.TableCatalog)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableSchema) == 1 {
		sql.AppendRaw(prepend, "TABLE_SCHEMA = ?")
		prepend = ","
		args = append(args, data.TableSchema)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableName) == 1 {
		sql.AppendRaw(prepend, "TABLE_NAME = ?")
		prepend = ","
		args = append(args, data.TableName)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageColumnName) == 1 {
		sql.AppendRaw(prepend, "COLUMN_NAME = ?")
		prepend = ","
		args = append(args, data.ColumnName)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageOrdinalPosition) == 1 {
		sql.AppendRaw(prepend, "ORDINAL_POSITION = ?")
		prepend = ","
		args = append(args, data.OrdinalPosition)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsagePositionInUniqueConstraint) == 1 {
		sql.AppendRaw(prepend, "POSITION_IN_UNIQUE_CONSTRAINT = ?")
		prepend = ","
		args = append(args, data.PositionInUniqueConstraint)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedTableSchema) == 1 {
		sql.AppendRaw(prepend, "REFERENCED_TABLE_SCHEMA = ?")
		prepend = ","
		args = append(args, data.ReferencedTableSchema)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedTableName) == 1 {
		sql.AppendRaw(prepend, "REFERENCED_TABLE_NAME = ?")
		prepend = ","
		args = append(args, data.ReferencedTableName)
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedColumnName) == 1 {
		sql.AppendRaw(prepend, "REFERENCED_COLUMN_NAME = ?")
		args = append(args, data.ReferencedColumnName)
	}
	sql.Append(" WHERE ")
	if zerolog.GlobalLevel() == zerolog.DebugLevel {
		log.Debug().Str("fn", "information_schema.KEY_COLUMN_USAGE.Update").Str("stmt", sql.String()).Interface("args", args).Msg("sql")
	}
	res, err :=
		ke.db.Exec(sql.Query(), args...)
	if err != nil {
		log.Error().Err(err).Msg("exec")
		return 0, err
	}
	return res.RowsAffected()
}

// Truncate deletes all rows from KeyColumnUsage.
func (ke *KeyColumnUsageStore) Truncate() error {
	sql := NewSQLStatement()
	sql.Append("TRUNCATE information_schema.KEY_COLUMN_USAGE")
	if zerolog.GlobalLevel() == zerolog.DebugLevel {
		log.Debug().Str("fn", "information_schema.KEY_COLUMN_USAGE.Truncate").Str("stmt", sql.String()).Msg("sql")
	}
	_, err := ke.db.Exec(sql.Query())
	if err != nil {
		log.Error().Err(err).Msg("exec")
	}
	return err
}

// ToJSON writes a single object to the buffer.
// nolint[gocylco]
func (ke *KeyColumnUsageStore) ToJSON(t *buffer.TemplateBuffer, data *KeyColumnUsage) {
	prepend := "{"
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintCatalog) == 1 {
		t.JS(prepend, "constraint_catalog", data.ConstraintCatalog)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintSchema) == 1 {
		t.JS(prepend, "constraint_schema", data.ConstraintSchema)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageConstraintName) == 1 {
		t.JS(prepend, "constraint_name", data.ConstraintName)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableCatalog) == 1 {
		t.JS(prepend, "table_catalog", data.TableCatalog)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableSchema) == 1 {
		t.JS(prepend, "table_schema", data.TableSchema)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageTableName) == 1 {
		t.JS(prepend, "table_name", data.TableName)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageColumnName) == 1 {
		t.JS(prepend, "column_name", data.ColumnName)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageOrdinalPosition) == 1 {
		t.JD64(prepend, "ordinal_position", data.OrdinalPosition)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsagePositionInUniqueConstraint) == 1 {
		t.JD64(prepend, "position_in_unique_constraint", data.PositionInUniqueConstraint)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedTableSchema) == 1 {
		t.JS(prepend, "referenced_table_schema", data.ReferencedTableSchema)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedTableName) == 1 {
		t.JS(prepend, "referenced_table_name", data.ReferencedTableName)
		prepend = ","
	}
	if ke.colSet == nil || ke.colSet.Bit(KeyColumnUsageReferencedColumnName) == 1 {
		t.JS(prepend, "referenced_column_name", data.ReferencedColumnName)
	}
	t.S(`}`)
}

// ToJSONArray writes a slice to the named array.
func (ke *KeyColumnUsageStore) ToJSONArray(w io.Writer, data []*KeyColumnUsage, name string) {
	t := buffer.NewTemplateBuffer()
	t.SS(`{"`, name, `":[`)
	for i := range data {
		if i > 0 {
			t.S(",")
		}
		ke.ToJSON(t, data[i])
	}

	t.S("]}")
	_, err := w.Write(t.Bytes())
	if err != nil {
		panic(err)
	}
}

// ^^ END OF GENERATED BY CODEGEN. DO NOT EDIT. ^^
