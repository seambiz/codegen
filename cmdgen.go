package codegen

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"github.com/Masterminds/sprig"
	"github.com/valyala/bytebufferpool"
)

var (
	codegenStart = []byte("// GENERATED BY CODEGEN. DO NOT EDIT.")
	codegenEnd   = []byte("// ^^ END OF GENERATED BY CODEGEN. DO NOT EDIT. ^^")
)

// GenBuffer type alias for shorter template functions
type GenBuffer struct {
	buf *bytebufferpool.ByteBuffer
}

// NewGenBuffer factory
func NewGenBuffer(bb *bytebufferpool.ByteBuffer) *GenBuffer {
	return &GenBuffer{buf: bb}
}

// NewLine write newline char to buffer
func (g *GenBuffer) NewLine() {
	_, err := g.buf.Write([]byte{'\n'})
	if err != nil {
		panic(err)
	}
}

// S shortcut for writing string to buffer and check error
func (g *GenBuffer) S(ss ...string) {
	for _, s := range ss {
		_, err := g.buf.WriteString(s)
		if err != nil {
			panic(err)
		}
	}
}

// Func shortcut for writing string to buffer and check error
func (g *GenBuffer) Func(receiver, funcName string) {
	g.S("func ")
	if receiver != "" {
		g.S("(")
		g.S(receiver)
		g.S(")")
	}
	g.S(" ")
	g.S(funcName)
}

// FuncParams shortcut for writing string to buffer and check error
func (g *GenBuffer) FuncParams(ss ...string) {
	g.S("(")
	for i, s := range ss {
		if i >= 1 {
			g.S(",")
		}
		g.S(s)
	}
	g.S(")")
}

// FuncEnd shortcut for writing string to buffer and check error
func (g *GenBuffer) FuncEnd() {
	g.S("}")
	g.NewLine()
}

// FuncReturn shortcut for writing string to buffer and check error
func (g *GenBuffer) FuncReturn(ss ...string) {
	if len(ss) == 0 {
		g.S("{")
		return
	}
	if len(ss) > 1 {
		g.S("(")
	}
	for i, s := range ss {
		if i >= 1 {
			g.S(",")
		}
		g.S(s)
	}
	if len(ss) > 1 {
		g.S(")")
	}
	g.S("{")
	g.NewLine()
}

// Struct shortcut for writing string to buffer and check error
func (g *GenBuffer) Struct(name string) {
	g.Line("type ", name, " struct {")
}

// StructEnd shortcut for writing string to buffer and check error
func (g *GenBuffer) StructEnd() {
	g.Line("}")
}

// Line shortcut for writing string to buffer and check error
func (g *GenBuffer) Line(ss ...string) {
	for _, s := range ss {
		g.S(s)
	}
	g.NewLine()
}

// LogField generates zerolog logging instruction for single field
func (g *GenBuffer) LogField(f *Field, prefix string) {
	switch f.GoType {
	case "[]byte":
		g.S("Bytes")
		break
	case "time.Time":
		g.S("Time")
		break
	case "sql.NullString":
		g.S("Str")
		break
	case "sql.NullInt64":
		g.S("Int64")
		break
	case "sql.NullFloat64":
		g.S("Float64")
		break
	case "string":
		g.S("Str")
		break
	default:
		g.S(strings.Title(f.GoType))
	}
	g.S(`("`)
	g.S(f.Title)
	g.S(`", `)
	if prefix != "" {
		g.S(prefix)
		g.S(".")
		g.S(f.Title)
	} else {
		g.S(f.ParamName)
	}
	switch f.GoType {
	case "sql.NullString":
		g.S(".Str")
		break
	case "sql.NullInt64":
		g.S(".Int64")
		break
	case "sql.NullFloat64":
		g.S(".Float64")
		break
	}
	g.S(")")
}

// Log generates zerolog logging instruction for array of fields
func (g *GenBuffer) Log(fields []*Field, prefix string) {

	for i, f := range fields {
		if i > 0 {
			g.S(".")
		}
		g.LogField(f, prefix)
	}
}

// Bytes returns buffer contents
func (g *GenBuffer) Bytes() []byte {
	return g.buf.Bytes()
}

// Free returns buffer to pool
func (g *GenBuffer) Free() {
	bytebufferpool.Put(g.buf)
}

/*
Initials extracts the initial letters from each word in the string. The first letter of the string and all first
letters after the defined delimiters are returned as a new string. Their case is not changed. If the delimiters
parameter is excluded, then Whitespace is used. Whitespace is defined by unicode.IsSpacea(char). An empty delimiter array returns an empty string.
Parameters:
    str - the string to get initials from
    delimiters - set of characters to determine words, exclusion of this parameter means whitespace would be delimeter
Returns:
    string of initial letters
*/
func Initials(str string, delimiters ...rune) string {
	if str == "" {
		return str
	}
	if delimiters != nil && len(delimiters) == 0 {
		return ""
	}
	strLen := len(str)
	var buf bytes.Buffer
	lastWasGap := true
	for i := 0; i < strLen; i++ {
		ch := rune(str[i])

		if isDelimiter(ch, delimiters...) {
			lastWasGap = true
		} else if lastWasGap {
			buf.WriteRune(ch)
			lastWasGap = false
		}
	}
	return buf.String()
}

// private function (lower case func name)
func isDelimiter(ch rune, delimiters ...rune) bool {
	if delimiters == nil {
		return unicode.IsSpace(ch)
	}
	for _, delimiter := range delimiters {
		if ch == delimiter {
			return true
		}
	}
	return false
}

// execCommand wraps exec.Command
func execCommand(command string) {
	parts := strings.Split(command, " ")
	if len(parts) == 0 {
		return
	}

	fmt.Println(parts)
	cmd := exec.Command(parts[0], parts[1:]...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout

	err := cmd.Run()
	if err != nil {
		fmt.Println("ERROR:", err)
	}
}

func lowerFirst(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

var commonInitialisms = []string{
	"ACL",
	"API",
	"ASCII",
	"CPU",
	"CSS",
	"DNS",
	"EOF",
	"GUID",
	"HTML",
	"HTTP",
	"HTTPS",
	"ID",
	"IP",
	"JSON",
	"LHS",
	"QPS",
	"RAM",
	"RHS",
	"RPC",
	"SLA",
	"SMTP",
	"SQL",
	"SSH",
	"TCP",
	"TLS",
	"TTL",
	"UDP",
	"UI",
	"UID",
	"UUID",
	"URI",
	"URL",
	"UTF8",
	"VM",
	"XML",
	"XMPP",
	"XSRF",
	"XSS",
}

// Generate main call to start generation
func Generate(conf *Config) {
	tableNr := 0
	for _, schema := range conf.Schemas {
		for _, table := range schema.Tables {
			if !table.Generate {
				continue
			}
			table.id = tableNr
			tableNr++

			// generate helper variables
			parts := strings.Split(table.Name, "_")
			for i := range parts {
				if strings.ToLower(parts[i]) == "id" {
					parts[i] = "ID"
				} else {
					parts[i] = strings.Title(parts[i])
				}
			}
			table.Title = strings.Join(parts, "")
			table.lower = lowerFirst(table.Title)
			table.initials = Initials(table.Name)
			table.initials += Initials(table.Name[1:])
			table.receiver = table.initials + " *" + table.Title
			table.store = table.Title + "Store"
			table.storeReceiver = table.initials + " *" + table.store

			// fill mapping for easy access to field properties
			table.FieldMapping = make(map[string]int)
			for i := range table.Fields {
				if table.Fields[i].Name == "id" {
					table.Fields[i].Title = "ID"
				} else {
					parts := strings.Split(table.Fields[i].Name, "_")
					for i := range parts {
						if strings.ToLower(parts[i]) == "id" {
							parts[i] = "ID"
						} else {
							parts[i] = strings.Title(parts[i])
						}
					}
					table.Fields[i].Title = strings.Join(parts, "")
				}
				// uppercase abbreviations
				for _, substring := range commonInitialisms {
					if strings.HasSuffix(strings.ToUpper(table.Fields[i].Title), substring) ||
						strings.HasPrefix(strings.ToUpper(table.Fields[i].Title), substring) {
						index := strings.Index(strings.ToUpper(table.Fields[i].Title), substring)
						stemp := table.Fields[i].Title[index : index+len(substring)]
						table.Fields[i].Title = strings.Replace(table.Fields[i].Title, stemp, substring, 1)
						break
					}
				}

				table.Fields[i].ParamName = strings.ToLower(table.Fields[i].Title)
				table.FieldMapping[table.Fields[i].Name] = i
				if table.Fields[i].IsPrimaryKey {
					table.pkFields = append(table.pkFields, table.Fields[i])
				} else {
					table.otherFields = append(table.otherFields, table.Fields[i])
				}
				typename, ok := GoTypeMapping[table.Fields[i].DBType]
				if !ok {
					panic(table.Fields[i].Name)
				}
				/*
					if table.Fields[i].IsNullable {
						//fmt.Println("NullType", table.Name, table.Fields[i].Title)
						nulltype, ok := goIsNullMapping[typename]
						if !ok {
							panic(table.Fields[i].Name)
						}
						typename = nulltype
					}
				*/
				table.Fields[i].GoType = typename
				zero, ok := goZeroMapping[typename]
				if !ok {
					panic(typename)
				}
				table.Fields[i].goZero = zero

				jsonFunc, ok := goJSONMapping[typename]
				if !ok {
					panic(typename)
				}
				table.Fields[i].jsonFunc = jsonFunc

				mappingFunc, ok := goDbMappingFunc[typename]
				if !ok {
					panic(typename)
				}
				table.Fields[i].mappingFunc = mappingFunc

				table.numFields = len(table.Fields)

				for _, fk := range table.ForeignKeys {
					if fk.IsUnique {
						table.numUniqueFKs += 1
					}
				}
			}
		}
	}

	if conf.TemplateFolder != "" {
		files, err := ioutil.ReadDir(conf.TemplateFolder)
		if err != nil {
			panic(err)
		}

		for _, f := range files {
			segments := strings.Split(f.Name(), ".")
			if len(segments) != 4 {
				panic("filename segment length != 4")
			}

			switch segments[0] {
			case "once":
				var buf bytes.Buffer

				contents, err := ioutil.ReadFile(conf.TemplateFolder + f.Name())
				if err != nil {
					panic(err)
				}

				tmpl, err := template.New(f.Name()).Funcs(sprig.TxtFuncMap()).Parse(string(contents))
				if err != nil {
					panic(err)
				}

				err = tmpl.Execute(&buf, conf)
				if err != nil {
					panic(err)
				}

				switch segments[1] {
				case "package":
					writeToCodgenFile(buf, conf, segments[2], conf.Package)
				case "root":
					writeToCodgenFile(buf, conf, segments[2], "")
				}

			case "table":
				contents, err := ioutil.ReadFile(conf.TemplateFolder + f.Name())
				if err != nil {
					panic(err)
				}

				tmpl, err := template.New(f.Name()).Funcs(sprig.TxtFuncMap()).Parse(string(contents))
				if err != nil {
					panic(err)
				}

				type GenData struct {
					Conf  Config
					Table Table
				}

				for _, s := range conf.Schemas {
					for _, t := range s.Tables {
						if !t.Generate {
							continue
						}
						var buf bytes.Buffer

						d := GenData{}
						d.Conf = *conf
						d.Table = *t

						err = tmpl.Execute(&buf, d)
						if err != nil {
							panic(err)
						}

						switch segments[1] {
						case "package":
							writeToCodgenFile(buf, conf, segments[2], conf.Package)
						case "root":
							writeToCodgenFile(buf, conf, t.Name+strings.Title(segments[2]), "")
						}
					}
				}
			}

		}
	} else {

		for _, schema := range conf.Schemas {
			for _, table := range schema.Tables {
				if !table.Generate {
					continue
				}
				bb := NewGenBuffer(bytebufferpool.Get())

				var templateFiles = table.Templates
				if len(templateFiles) == 0 {
					templateFiles = conf.Templates
				}

				for _, templateFile := range templateFiles {
					switch templateFile {
					case "header":
						THeader(bb, conf, schema)
					case "delete":
						TDelete(bb, conf, schema, table)
					case "insert":
						TInsert(bb, conf, schema, table)
					case "truncate":
						TTruncate(bb, conf, schema, table)
					case "update":
						TUpdate(bb, conf, schema, table)
					case "upsert":
						TUpsert(bb, conf, schema, table)
					case "type":
						TType(bb, conf, schema, table)
					case "foreign":
						TForeign(bb, conf, schema, table)
					case "json":
						TJSON(bb, conf, schema, table)
					case "end":
						TEnd(bb)
					case "index":
						type set map[string]struct{}
						indexSet := set{}

						for i := range table.Indices {
							if len(table.Indices[i].Fields) == 1 {
								indexSet[table.Indices[i].Fields[0]] = struct{}{}
							}
						}

						for i := range table.Indices {
							if len(table.Indices[i].Fields) > 1 {
								if _, ok := indexSet[table.Indices[i].Fields[0]]; ok {
									continue
								}
								index := *table.Indices[i]
								index.IsUnique = false
								index.Fields = []string{table.Indices[i].Fields[0]}
								table.Indices = append(table.Indices, &index)
							}
							indexSet[table.Indices[i].Fields[0]] = struct{}{}

						}

						for _, index := range table.Indices {
							TIndex(bb, conf, schema, table, index)
						}
					}
				}
				writeBufferToCodgenFile(bb, conf, table.Name)
			}
		}

		// global files
		s := &Schema{Name: "constants"}
		bb := NewGenBuffer(bytebufferpool.Get())
		THeader(bb, conf, s)
		TGlobalType(bb, conf)
		writeBufferToCodgenFile(bb, conf, "constants")
	}

	execCommand("goimports -w " + conf.DirOut)
	if conf.LintPackage != "" {
		execCommand("go vet " + conf.LintPackage)
	}
	if conf.MetaLinter != "" {
		execCommand(conf.MetaLinter)
	}
}
func writeBufferToCodgenFile(bb *GenBuffer, conf *Config, filename string) {
	fileName := filepath.Join(conf.DirOut, fmt.Sprintf(conf.FilePattern, strings.ToLower(strings.Replace(filename, "_", "", -1))))
	fmt.Println("Writing to", fileName)

	// check if file exists and if it already has codegen comments
	// if not, just write everything to the file
	if _, err := os.Stat(fileName); os.IsNotExist(err) {
		err := ioutil.WriteFile(fileName, bb.Bytes(), os.ModePerm)
		bb.Free()
		if err != nil {
			panic(err)
		}
	} else {
		fileContents, err := ioutil.ReadFile(fileName)
		if err != nil {
			panic(err)
		}

		if bytes.Contains(fileContents, codegenStart) && bytes.Contains(fileContents, codegenEnd) {
			start := bytes.Index(fileContents, codegenStart)
			if start == -1 {
				panic("start == -1")
			}
			end := bytes.LastIndex(fileContents, codegenEnd)
			if end == -1 {
				panic("end == -1")
			}

			newStart := bytes.Index(bb.Bytes(), codegenStart)
			if newStart == -1 {
				panic("newStart == -1")
			}
			newEnd := bytes.LastIndex(bb.Bytes(), codegenEnd)
			if newEnd == -1 {
				panic("newEnd == -1")
			}

			var newContent []byte
			newContent = append(newContent, fileContents[:start]...)
			newContent = append(newContent, bb.Bytes()[newStart:newEnd]...)
			newContent = append(newContent, fileContents[end:]...)

			err := ioutil.WriteFile(fileName, newContent, os.ModePerm)
			bb.Free()
			if err != nil {
				panic(err)
			}

		} else {
			fmt.Println("ERR: existing file (" + fileName + ") does not contain codegen comment.")
			fmt.Println("ERR: exiting now, so content does not get overwritten.")
			os.Exit(1)
		}
	}
}

func writeToCodgenFile(buf bytes.Buffer, conf *Config, filename string, subfolder string) {
	fileName := filepath.Join(conf.DirOut, subfolder, fmt.Sprintf(conf.FilePattern, strings.ToLower(strings.Replace(filename, "_", "", -1))))
	fmt.Println("Writing to", fileName)

	// check if file exists and if it already has codegen comments
	// if not, just write everything to the file
	if _, err := os.Stat(fileName); os.IsNotExist(err) {
		err := ioutil.WriteFile(fileName, buf.Bytes(), os.ModePerm)
		if err != nil {
			panic(err)
		}
	} else {
		fileContents, err := ioutil.ReadFile(fileName)
		if err != nil {
			panic(err)
		}

		if bytes.Contains(fileContents, codegenStart) && bytes.Contains(fileContents, codegenEnd) {
			start := bytes.Index(fileContents, codegenStart)
			if start == -1 {
				panic("start == -1")
			}
			end := bytes.LastIndex(fileContents, codegenEnd)
			if end == -1 {
				panic("end == -1")
			}

			newStart := bytes.Index(buf.Bytes(), codegenStart)
			if newStart == -1 {
				panic("newStart == -1")
			}
			newEnd := bytes.LastIndex(buf.Bytes(), codegenEnd)
			if newEnd == -1 {
				panic("newEnd == -1")
			}

			var newContent []byte
			newContent = append(newContent, fileContents[:start]...)
			newContent = append(newContent, buf.Bytes()[newStart:newEnd]...)
			newContent = append(newContent, fileContents[end:]...)

			err := ioutil.WriteFile(fileName, newContent, os.ModePerm)
			if err != nil {
				panic(err)
			}

		} else {
			fmt.Println("ERR: existing file (" + fileName + ") does not contain codegen comment.")
			fmt.Println("ERR: exiting now, so content does not get overwritten.")
			os.Exit(1)
		}
	}
}
