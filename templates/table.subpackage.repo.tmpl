{{- $schema := .Schema }}
{{- $table := .Table }}
{{- $conf := .Conf }}
package {{ $conf.SubPackage }}


import (
	{{ $conf.RootPackage }} "{{ $conf.RootPackageInclude }}"
)


// GENERATED BY CODEGEN. 
// ^^ END OF GENERATED BY CODEGEN. ^^

/* {{ $table.Title }}Repo implements {{ $table.Title }}Repository interface definition. */
type {{ $table.Title }}Repo struct {
	conn *sql.DB
	ctx *{{ $conf.RootPackage }}.BaseContext
}

func New{{ $table.Title }}Repo(ctx *{{ $conf.RootPackage }}.BaseContext, conn *sql.DB) {{ $conf.RootPackage }}.{{ $table.Title}}Repository {
	return &{{ $table.Title}}Repo{
		conn: conn,
		ctx: ctx,
	}
}
	
{{- if $schema.IsMultiTenant }}
	{{ if not .Table.NoCreate }}func (r {{ $table.Title }}Repo) Create({{ if .Table.Audit }}userID int, {{ end }}{{ $schema.MTVarName }} {{ $schema.MTVarType }}, data *{{ $conf.RootPackage }}.{{ .Table.Title }}) error { panic("not implemented") }{{ end }}
	{{ if not .Table.NoUpdate }}func (r {{ $table.Title }}Repo) Update({{ if .Table.Audit }}userID int, {{ end }}{{ $schema.MTVarName }} {{ $schema.MTVarType }}, data *{{ $conf.RootPackage }}.{{ .Table.Title }}) error { panic("not implemented") }{{ end }}
	{{ if not .Table.NoUpdate }}func (r {{ $table.Title }}Repo) UpdatePartial({{ if .Table.Audit }}userID int, {{ end }}{{ $schema.MTVarName }} {{ $schema.MTVarType }}, data *{{ $conf.RootPackage }}.{{ .Table.Title }}Partial) error { panic("not implemented") }{{ end }}
	{{ if not .Table.NoUpsert }}func (r {{ $table.Title }}Repo) Upsert({{ if .Table.Audit }}userID int, {{ end }}{{ $schema.MTVarName }} {{ $schema.MTVarType }}, data []*{{ $conf.RootPackage }}.{{ .Table.Title }}) error { panic("not implemented") }{{ end }}
	{{ if not .Table.NoDelete }}func (r {{ $table.Title }}Repo) Delete({{ if .Table.Audit }}userID int, {{ end }}{{ $schema.MTVarName }} {{ $schema.MTVarType }}, data *{{ $conf.RootPackage }}.{{ .Table.Title }}) error { panic("not implemented") }{{ end }}
{{ else }}
	{{ if not $table.NoCreate -}}
	func (r {{ $table.Title }}Repo) Create({{ if .Table.Audit }}userID int, {{ end }}data *{{ $conf.RootPackage }}.{{ $table.Title }}) error {
		panic("not implemented")
	}
	{{ end }}

		
	{{ if not $table.NoUpdate -}}
	func (r {{ $table.Title }}Repo) Update({{ if .Table.Audit }}userID int, {{ end }}data *{{ $conf.RootPackage }}.{{ $table.Title }}) error {
		panic("not implemented")
	}
	{{ end }}
		
	{{ if not $table.NoUpdate -}}
	func (r {{ $table.Title }}Repo) UpdatePartial({{ if .Table.Audit }}userID int, {{ end }}data *{{ $conf.RootPackage }}.{{ $table.Title }}Partial) error {
		panic("not implemented")
	}
	{{ end }}

	{{ if not .Table.NoUpsert }}func (r {{ $table.Title }}Repo) Upsert({{ if .Table.Audit }}userID int, {{ end }}data []*{{ $conf.RootPackage }}.{{ .Table.Title }}) error { panic("not implemented") }{{ end }}
		
	{{ if not $table.NoDelete -}}
	func (r {{ $table.Title }}Repo) Delete({{ if .Table.Audit }}userID int, {{ end }}data *{{ $conf.RootPackage }}.{{ $table.Title }}) error {
		panic("not implemented")
	}
	{{- end }}
{{ end }}

	{{- range $index := $table.Indices }}
		{{- if $index.Generate }}
		{{- if $index.IsUnique }}
		func (r {{ $table.Title }}Repo) OneBy
			{{- range $i, $field := $index.Fields -}}
				{{- if gt $i 0 -}}
					And
				{{- end -}}
				{{ $f := index $table.Fields (index  $table.FieldMapping $field) }}{{ $f.Title }}
			{{- end -}}
			
			{{- if $schema.IsMultiTenant -}}
				({{ $schema.MTVarName }} {{ $schema.MTVarType }},
			{{- else -}}
				(
			{{- end }}
			
			{{- range $i, $field := $index.Fields -}}
				{{- if gt $i 0 -}}
					,
				{{- end -}}
				{{ $f := index $table.Fields (index  $table.FieldMapping $field) }}{{  $f.ParamName }} {{ $f.GoType }}
			{{- end -}}
			) (*{{ $conf.RootPackage }}.{{ $table.Title }}, error) {
				panic("not implemented")
			}
		{{- end -}}
		{{- end -}}
	{{ end }}
