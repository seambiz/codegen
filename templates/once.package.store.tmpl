package {{ .Conf.Package }}

import (
	"database/sql"
	"math/big"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

// GENERATED BY CODEGEN. DO NOT EDIT.

// nolint[structcheck]
type Store struct {
	db           Execer
	withJoin     bool
	selectCalled bool
	joinType     string
	where        string
	orderBy      string
	groupBy      string
	prependField string
	limit        int
	offset       int
	batch        int
	colSet       *big.Int
	stmt         *sdb.SQLStatement
	{{- if .Schema.IsMultiTenant }}
    {{ .Schema.MTVarName }} {{ .Schema.MTVarType }}
	{{- end }}
}

type (
	Row    []Bindable
	Result []Row
)

// NewStore return DAO Storr
func NewStore(conn Execer) *Store {
	s := &Store{}
	s.db = conn
	s.stmt = sdb.NewSQLStatement()
	return s
}

func (s *Store) SQL(stmt string) *Store {
	s.stmt.Append(stmt)
	return s
}

func (s *Store) BindSlice(res *Result, rowStructs Row) *Store {
	for i := range rowStructs {
		s.dtos = append(s.dtos, rowStructs[i])
	}
	s.dtoslice = res
	return s
}

func (s *Store) Bind(datas ...Bindable) *Store {
	for i := range datas {
		s.dtos = append(s.dtos, datas[i])
	}
	return s
}

func (s *Store) Select(columns string) *Store {
	s.stmt.Append("SELECT", columns)
	s.selectCalled = true
	return s
}

// QueryInto uses sqlx.Select for raw SQL querying. Mapping uses tag (db) or field name.
func (s *Store) QueryInto(dest interface{}, args ...interface{}) error {
	dbx := sqlx.NewDb(s.db.(*sql.DB), "mysql")
	log.Debug().Str("fn", "Store.QueryInto").Str("stmt", s.stmt.String()).Interface("args", args).Msg("sql")
	return dbx.Select(dest, s.stmt.Query(), args...)
}
 
// OneInto uses sqlx.Get for raw SQL querying. Mapping uses tag (db) or field name.
func (s *Store) OneInto(dest interface{}, args ...interface{}) error {
	dbx := sqlx.NewDb(s.db.(*sql.DB), "mysql")
	log.Debug().Str("fn", "Store.QueryInto").Str("stmt", s.stmt.String()).Interface("args", args).Msg("sql")
	return dbx.Get(dest, s.stmt.Query(), args...)
}

func (s *Store) From(table string) *Store {
	s.stmt.Append(" FROM", table)
	return s
}

func (s *Store) Join(table, condition string) *Store {
	s.stmt.Append("INNER JOIN", table, "ON", condition)
	return s
}

func (s *Store) LeftJoin(table, condition string) *Store {
	s.stmt.Append("LEFT JOIN", table, "ON", condition)
	return s
}

func (s *Store) RightJoin(table, condition string) *Store {
	s.stmt.Append("RIGHT JOIN", table, "ON", condition)
	return s
}

func (s *Store) Where(condition string) *Store {
	s.stmt.Append("WHERE", condition)
	return s
}

func (s *Store) OrderBy(columns string) *Store {
	s.stmt.Append("ORDER BY", columns)
	return s
}

func (s *Store) Limit(limits ...int) *Store {
	if len(limits) == 0 {
		return s
	}
	s.stmt.Append("LIMIT", limits[0])
	if len(limits) > 1 {
		s.stmt.Append(",", limits[1])
	}
	return s
}

// Columns to be used for various statements.
func (s *Store) Columns(cols ...int) *Store {
	if s.stmt != nil && !s.selectCalled {
		s.stmt.Append("SELECT")
	}
	if s.colSet == nil {
		s.colSet = big.NewInt(0)
	}
	for _, col := range cols {
		s.colSet.SetBit(s.colSet, col, 1)
	}
	return s
}

func (s *Store) Fields(prefix string, fieldFunc func(*big.Int) []string) *Store {
	s.stmt.Fields(s.prependField, prefix, fieldFunc(s.colSet))
	s.prependField = ","
	return s
}

// queryBegin is a helper for other querying funcs.
func (s *Store) queryBegin(stmt string, args ...interface{}) (*sql.Rows, []sql.RawBytes, []interface{}, error) {
	if zerolog.GlobalLevel() == zerolog.DebugLevel {
		log.Debug().Str("fn", "Store.One").Str("stmt", stmt).Interface("args", args).Msg("sql")
	}
	rows, err := s.db.Query(stmt, args...)
	if err != nil {
		log.Error().Err(err).Msg("query")
		return nil, nil, nil, err
	}
	colNames, err := rows.Columns()
	if err != nil {
		log.Error().Err(err).Msg("colNames")
		return nil, nil, nil, err
	}
	columnValues := make([]sql.RawBytes, len(colNames))
	columnPointers := make([]interface{}, len(colNames))
	for i := range columnValues {
		columnPointers[i] = &columnValues[i]
	}
	return rows, columnValues, columnPointers, err
}

// one is a helper for other stores' One's funcs.
func (s *Store) one(data Bindable, stmt *sdb.SQLStatement, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
		col := 0
		data.bind(values, s.withJoin, s.colSet, &col)
	} else {
		return sql.ErrNoRows
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// MapScan gets a single row from a custom query.
func (s *Store) MapScan(dest map[string]sql.RawBytes, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}

		var columns []string
		columns, err = rows.Columns()
		if err != nil {
			log.Error().Err(err).Msg("columns")
			return err
		}

		for i, column := range columns {
			dest[column] = values[i]
		}
	} else {
		return sql.ErrNoRows
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// One retrieves a single row with optionally joined data.
func (s *Store) One(args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
		col := 0
		for i := range s.dtos {
			s.dtos[i].bind(values, s.withJoin, s.colSet, &col)
		}
	} else {
		return sql.ErrNoRows
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// OneValue retrieves a single column from the first row as generic interface{}.
// Specify the bindFunc to map the DB return value to the correct type.
func (s *Store) OneValue(bindFunc func([]byte) interface{}, args ...interface{}) (interface{}, error) {
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return false, err
	}
	defer rows.Close()

	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return false, err
		}
		return bindFunc(values[0]), nil
	}
	return false, sql.ErrNoRows
}

// OneString retrieves a single column from the first row as string.
func (s *Store) OneString(args ...interface{}) (string, error) {
	v, err := s.OneValue(func(b []byte) interface{} {
		return sdb.ToString(b)
	}, args...)
	return v.(string), err
}

// OneInt retrieves a single column from the first row as int.
func (s *Store) OneInt(args ...interface{}) (int, error) {
	v, err := s.OneValue(func(b []byte) interface{} {
		return sdb.ToInt(b)
	}, args...)
	return v.(int), err
}

// OneBool retrieves a single column from the first row as bool.
func (s *Store) OneBool(args ...interface{}) (bool, error) {
	v, err := s.OneValue(func(b []byte) interface{} {
		return sdb.ToBool(b)
	}, args...)
	return v.(bool), err
}

// QueryCustom retrieves many rows from 'best.bestellung' as a slice of Bestellung with possible joined data.
func (s *Store) queryCustom(res BindableSlice, d Bindable, stmt string, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(stmt, args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	col := 0
	for rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
		data := d.new()
		col = 0
		data.bind(values, s.withJoin, s.colSet, &col)
		res.append(data)
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// Query retrieves many rows.
func (s *Store) Query(args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	for rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
		col := 0
		row := Row{}
		for i := range s.dtos {
			d := s.dtos[i].new()
			d.bind(values, false, s.colSet, &col)
			row = append(row, d)
		}
		*s.dtoslice = append(*s.dtoslice, row)
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// ^^ END OF GENERATED BY CODEGEN. DO NOT EDIT. ^^
