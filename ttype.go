package codegen

import (
	"strings"
)

func fkVariable(bb *GenBuffer, conf *Config, table *Table, fks []*ForeignKey) {
	for _, fk := range fks {
		fkRefTable := strings.Title(fk.RefTable)
		fkSchema := conf.getSchema(fk.RefSchema)
		if t := fkSchema.getTable(fk.RefTable); t != nil {
			fkRefTable = t.Title
		}
		if fk.CustomName == "" {
			fk.CustomName = table.Title + strings.Replace(fk.Name, "fk", "", 1)
		}

		bb.S(fk.CustomName)
		bb.S(" ")
		if !fk.IsUnique {
			bb.S("[]")
		}
		bb.S("*")
		bb.Line(fkRefTable)

		if len(fk.ForeignKeys) > 0 {
			fkVariable(bb, conf, table, fk.ForeignKeys)
		}
	}
}

func checkJoinFields(bb *GenBuffer, table *Table, fks []*ForeignKey) {
	for _, fk := range fks {
		if fk.IsUnique {
			if fk.CustomName == "" {
				fk.CustomName = table.Title + strings.Replace(fk.Name, "fk", "", 1)
			}

			bb.Line("if ", table.initials, ".", fk.CustomName, ".IsEmpty() {")
			bb.Line(table.initials, ".", fk.CustomName, " = nil")
			bb.Line("}")

			if len(fk.ForeignKeys) > 0 {
				checkJoinFields(bb, table, fk.ForeignKeys)
			}
		}
	}
}

// TType template
func TType(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {

	bb.S("// GENERATED BY CODEGEN. DO NOT EDIT.")
	bb.NewLine()

	bb.Line("// constant slice for all fields of the table.")
	bb.Line("// nolint[gochecknoglobals]")
	bb.S("var ", strings.ToLower(table.Title), "QueryFieldsAll = []string{")
	for i, f := range table.Fields {
		if i > 0 {
			bb.S(",")
		}
		bb.S(`"` + strings.ToLower(f.Name) + `"`)
	}
	bb.Line(`}`)
	bb.NewLine()

	bb.Line("// returns fields, that should be used.")
	bb.Line("// nolint[gocyclo]")
	bb.Func("", table.Title+"QueryFields")
	bb.FuncParams("colSet *big.Int")
	bb.FuncReturn("[]string")
	bb.Line("if colSet == nil {")
	bb.S("return ", strings.ToLower(table.Title), "QueryFieldsAll")

	bb.Line("}")
	bb.NewLine()
	bb.Line("fields := []string{}")
	for _, f := range table.Fields {
		bb.Line("if colSet.Bit(" + table.Title + f.Title + ") == 1 {")
		bb.Line(`fields = append(fields, "` + strings.ToLower(f.Name) + `")`)
		bb.Line("}")
	}
	bb.Line("return fields")
	bb.FuncEnd()
	bb.NewLine()

	bb.Line("// ", table.Title, " represents a row from '", schema.Name, ".", table.Name, "'.")

	bb.Struct(table.Title)
	for _, f := range table.Fields {
		bb.Line(f.Title, " ", f.GoType, " `json:\"", f.Name, `" db:"`, strings.ToLower(f.Name), "\"`")
	}
	if len(table.ForeignKeys) > 0 {
		bb.NewLine()
	}
	fkVariable(bb, conf, table, table.ForeignKeys)
	bb.StructEnd()

	bb.Line("// new implements DTO.new")
	bb.Func(table.receiver, "new")
	bb.FuncParams()
	bb.FuncReturn("DTO")
	bb.Line("return &", table.Title, "{}")
	bb.FuncEnd()

	bb.Line("// helper struct for common query operations.")
	bb.Struct(table.Title + "Slice")
	bb.Line("data []*", table.Title)
	bb.StructEnd()

	bb.Line("// append implements DTOSlice.append")
	bb.Func(table.receiver+"Slice", "append")
	bb.FuncParams("d DTO")
	bb.FuncReturn("")
	bb.Line(table.initials, ".data = append(", table.initials, ".data, d.(*", table.Title, "))")
	bb.FuncEnd()

	bb.Line("// Columns to be used for various statements.")
	bb.Func(table.storeReceiver, "Columns")
	bb.FuncParams("cols ...int")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, `.colSet = big.NewInt(0)
	for _, col := range cols {
		`, table.initials, `.colSet.SetBit(`, table.initials, `.colSet, col, 1)
	}
	return `, table.initials)
	bb.FuncEnd()

	bb.Line("// IsEmpty checks if primary key fields are zero.")
	bb.Func(table.receiver, "IsEmpty")
	bb.FuncParams()
	bb.FuncReturn("bool")
	if len(table.pkFields) == 1 {
		bb.Line("return ", table.initials, ".", table.pkFields[0].Title, " == ", table.pkFields[0].goZero)
	} else {
		for _, f := range table.pkFields {
			bb.Line("if ", table.initials, ".", f.Title, " != ", f.goZero, " {")
			bb.Line("return false")
			bb.Line("}")
		}
		bb.Line("return true")
	}
	bb.FuncEnd()

	if len(table.ForeignKeys) > 0 {
		bb.Line("// checkJoinFields checks if join was successful and if not resets pointers to nil.")
		bb.Func(table.receiver, "checkJoinFields")
		bb.FuncParams()
		bb.FuncReturn()

		checkJoinFields(bb, table, table.ForeignKeys)

		bb.FuncEnd()
	}

	bb.Line("// ", table.store, " is used to query for '", table.Title, "' records.")
	bb.Struct(table.store)
	bb.Line("Store")
	bb.StructEnd()

	bb.Line("// New", table.Title, "Store return DAO Store for ", table.Title)
	bb.Func("", "New"+table.Title+"Store")
	bb.FuncParams("conn *sql.DB")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, " := &", table.store, "{}")
	bb.Line(table.initials, ".db = conn")
	bb.Line(table.initials, ".withJoin = true")
	bb.Line(table.initials, `.joinType = sdb.LEFT`)
	bb.Line(table.initials, `.batch = 1000`)
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// WithoutJoins won't execute JOIN when querying for records.")
	bb.Func(table.storeReceiver, "WithoutJoins")
	bb.FuncParams()
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".withJoin = false")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// Where sets local sql, that will be appended to SELECT.")
	bb.Func(table.storeReceiver, "Where")
	bb.FuncParams("sql string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".where = sql")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// OrderBy sets local sql, that will be appended to SELECT.")
	bb.Func(table.storeReceiver, "OrderBy")
	bb.FuncParams("sql string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".orderBy = sql")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// GroupBy sets local sql, that will be appended to SELECT.")
	bb.Func(table.storeReceiver, "GroupBy")
	bb.FuncParams("sql string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".groupBy = sql")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// Limit result set size")
	bb.Func(table.storeReceiver, "Limit")
	bb.FuncParams("n int")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".limit = n")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// Offset used, if a limit is provided")
	bb.Func(table.storeReceiver, "Offset")
	bb.FuncParams("n int")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".offset = n")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// JoinType sets join statement type (Default: INNER | LEFT | RIGHT | OUTER).")
	bb.Func(table.storeReceiver, "JoinType")
	bb.FuncParams("jt string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".joinType = jt")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	/*
	   wird jetzt mittels bind gemacht
	   	// func fields
	   	bb.Func(table.receiver, "scanFields")
	   	bb.FuncParams("withJoin bool")
	   	bb.FuncReturn("[]interface{}")

	   	bb.Line("f := []interface{}{}")
	   	for _, f := range table.Fields {
	   		bb.Line("f = append(f, &", table.initials, ".", f.Title, ")")
	   	}
	   	if len(table.ForeignKeys) > 0 {
	   		bb.Line("if withJoin {")
	   		for _, fk := range table.ForeignKeys {
	   			if fk.IsUnique {
	   				var fkRefTable *Table
	   				fkSchema := conf.getSchema(fk.RefSchema)
	   				if t := fkSchema.getTable(fk.RefTable); t != nil {
	   					fkRefTable = t
	   				}
	   				if fk.CustomName == "" {
	   					fk.CustomName = table.Title + strings.Replace(fk.Name, "fk", "", 1)
	   				}

	   				for _, f := range fkRefTable.Fields {
	   					bb.Line("f = append(f, &", table.initials, ".", fk.CustomName, ".", f.Title, ")")
	   				}

	   			}
	   		}
	   	}
	   	bb.Line("}")
	   	bb.Line("return f")
	   	bb.FuncEnd()
	*/

	bind(bb, conf, schema, table)
	selectSQL(bb, conf, schema, table)
	oneSelect(bb, conf, schema, table)
	querySelect(bb, conf, schema, table)
	queryCustom(bb, conf, schema, table)
}

func bindJoin(bb *GenBuffer, conf *Config, table *Table, fks []*ForeignKey) {
	for _, fk := range fks {
		if fk.IsUnique {
			var fkRefTable *Table
			fkSchema := conf.getSchema(fk.RefSchema)
			if t := fkSchema.getTable(fk.RefTable); t != nil {
				fkRefTable = t
			}
			if fk.CustomName == "" {
				fk.CustomName = table.Title + strings.Replace(fk.Name, "fk", "", 1)
			}

			bb.Line(table.initials, ".", fk.CustomName, "= &", fkRefTable.Title, "{}")
			bb.Line(table.initials, ".", fk.CustomName, ".bind(row, false, colSet, col)")

			if len(fk.ForeignKeys) > 0 {
				bindJoin(bb, conf, table, fk.ForeignKeys)
			}
		}
	}

}

func bind(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	// func fields
	bb.Line("// nolint[gocyclo]")
	bb.Func(table.receiver, "bind")
	bb.FuncParams("row []sql.RawBytes", "withJoin bool", "colSet *big.Int", "col *int")
	bb.FuncReturn()

	for i, f := range table.Fields {
		bb.Line("if colSet == nil || colSet.Bit(", table.Title+f.Title, ") == 1 {")
		if f.mappingFunc != "" {
			bb.Line(table.initials, ".", f.Title, " = ", f.mappingFunc, "(row[*col])")
		} else {
			bb.Line(table.initials, ".", f.Title, " = row[*col]")
		}
		if i < table.numFields || len(table.ForeignKeys) > 0 {
			bb.Line("*col++")
		}
		bb.Line("}")
	}
	if len(table.ForeignKeys) > 0 {
		bb.Line("if withJoin {")
		bindJoin(bb, conf, table, table.ForeignKeys)
		bb.Line("}")
	}
	bb.FuncEnd()
}

func selectJoinFields(bb *GenBuffer, conf *Config, table *Table, tableAlias *rune, fks []*ForeignKey) {
	for _, fk := range fks {
		*tableAlias++
		if fk.IsUnique {
			fkRefTable := strings.Title(fk.RefTable)
			fkSchema := conf.getSchema(fk.RefSchema)
			if t := fkSchema.getTable(fk.RefTable); t != nil {
				fkRefTable = t.Title
			}
			bb.Line(`sql.Fields(",","`, string(*tableAlias), `",`, fkRefTable, `QueryFields(`, table.initials, `.colSet))`)

			if len(fk.ForeignKeys) > 0 {
				selectJoinFields(bb, conf, table, tableAlias, fk.ForeignKeys)
			}
		}
	}
}

func selectJoinTable(bb *GenBuffer, conf *Config, table *Table, refAlias rune, tableAlias *rune, fks []*ForeignKey) {
	for _, fk := range fks {
		*tableAlias++
		if fk.IsUnique {
			fkSchema := conf.getSchema(fk.RefSchema)
			// TODO Join type
			bb.S(`sql.Append(`, table.initials, ".joinType", `," JOIN `, fkSchema.Name, ".", fk.RefTable, " ", string(*tableAlias), " ON (")
			for i, f := range fk.Fields {
				if i > 0 {
					bb.S(" AND ")
				}
				bb.S(string(refAlias), ".", f, " = ", string(*tableAlias), ".", fk.RefFields[i])
			}
			bb.Line(`)")`)

			if len(fk.ForeignKeys) > 0 {
				selectJoinTable(bb, conf, table, *tableAlias, tableAlias, fk.ForeignKeys)
			}
		}
	}
}

// selectSQL generates general SELECT Statement with optional JOINs based on foreign key definitions
func selectSQL(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Func(table.storeReceiver, "selectStatement")
	bb.FuncParams()
	bb.FuncReturn("*SQLStatement")

	tableAlias := 'A'
	bb.Line("sql := NewSQLStatement()")
	bb.Line(`sql.Append("SELECT")`)
	bb.Line(`sql.Fields("","`, string(tableAlias), `", `, table.Title, `QueryFields(`, table.initials, `.colSet))`)
	if table.numUniqueFKs > 1 {
		bb.Line("if ", table.initials, ".withJoin {")
		{
			selectJoinFields(bb, conf, table, &tableAlias, table.ForeignKeys)
			bb.Line(`sql.Append("FROM `, schema.Name, ".", table.Name, ` A")`)
			tableAlias := 'A'
			selectJoinTable(bb, conf, table, 'A', &tableAlias, table.ForeignKeys)
		}
		bb.Line("} else {")
	}
	{
		bb.Line(`sql.Append("FROM `, schema.Name, ".", table.Name, ` A")`)
	}
	if table.numUniqueFKs > 1 {
		bb.Line("}")
	}

	bb.Line("if ", table.initials, `.where != "" {`)
	bb.Line(`sql.Append("WHERE", `, table.initials, ".where)")
	bb.Line("}")
	bb.Line("if ", table.initials, `.groupBy != "" {`)
	bb.Line(`sql.Append("GROUP BY", `, table.initials, ".groupBy)")
	bb.Line("}")
	bb.Line("if ", table.initials, `.orderBy != "" {`)
	bb.Line(`sql.Append("ORDER BY", `, table.initials, ".orderBy)")
	bb.Line("}")
	bb.Line("if ", table.initials, `.limit > 0 {`)
	bb.Line(`sql.AppendRaw("LIMIT ", `, table.initials, ".limit)")
	bb.Line("if ", table.initials, `.offset > 0 {`)
	bb.Line(`sql.AppendRaw(",", `, table.initials, ".offset)")
	bb.Line("}")
	bb.Line("}")
	bb.Line("return sql")
	bb.FuncEnd()
}

func oneSelect(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Line("// One retrieves a row from '", schema.Name, ".", table.Name, "' as a ", table.Title, " with possible joined data.")
	bb.Func(table.storeReceiver, "One")
	bb.FuncParams("args ...interface{}")
	bb.FuncReturn("*"+table.Title, "error")

	bb.Line("data := &", table.Title, "{}")
	bb.NewLine()

	bb.Line("err := ", table.initials, ".one(data, ", table.initials, ".selectStatement(), args...)")
	bb.Line("if err != nil {")
	bb.Line("log.Error().Err(err).Msg(\"query one\")")
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("return data, nil")
	bb.FuncEnd()
}

func querySelect(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Line("// Query retrieves many rows from '", schema.Name, ".", table.Name, "' as a slice of ", table.Title, " with possible joined data.")
	bb.Func(table.storeReceiver, "Query")
	bb.FuncParams("args ...interface{}")
	bb.FuncReturn("[]*"+table.Title, "error")

	bb.Line("stmt := ", table.initials, ".selectStatement()")
	bb.Line("return ", table.initials, ".QueryCustom(stmt.Query(), args...)")
	bb.FuncEnd()
}

func queryCustom(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Line("// QueryCustom retrieves many rows from '", schema.Name, ".", table.Name, "' as a slice of ", table.Title, " with possible joined data.")
	bb.Func(table.storeReceiver, "QueryCustom")
	bb.FuncParams("stmt string", "args ...interface{}")
	bb.FuncReturn("[]*"+table.Title, "error")

	bb.Line("dto := &", table.Title, "{}")
	bb.Line("data := &", table.Title, "Slice{}")

	bb.Line("err := ", table.initials, ".queryCustom(data, dto, stmt, args...)")
	bb.Line("if err != nil {")
	bb.Line(`log.Error().Err(err).Msg("querycustom")`)
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("return data.data, nil")

	bb.FuncEnd()
}
