package codegen

import (
	"strconv"
	"strings"
)

func fkVariable(bb *GenBuffer, conf *Config, table *Table, fks []*ForeignKey) {
	for _, fk := range fks {
		fkRefTable := strings.Title(fk.RefTable)
		fkSchema := conf.getSchema(fk.RefSchema)
		if t := fkSchema.getTable(fk.RefTable); t != nil {
			fkRefTable = t.title
		}
		if fk.CustomName == "" {
			fk.CustomName = table.title + strings.Replace(fk.Name, "fk", "", 1)
		}

		bb.S(fk.CustomName)
		bb.S(" ")
		if !fk.IsUnique {
			bb.S("[]")
		}
		bb.S("*")
		bb.Line(fkRefTable)

		if len(fk.ForeignKeys) > 0 {
			fkVariable(bb, conf, table, fk.ForeignKeys)
		}
	}
}

func checkJoinFields(bb *GenBuffer, table *Table, fks []*ForeignKey) {
	for _, fk := range fks {
		if fk.IsUnique {
			if fk.CustomName == "" {
				fk.CustomName = table.title + strings.Replace(fk.Name, "fk", "", 1)
			}

			bb.Line("if ", table.initials, ".", fk.CustomName, ".IsEmpty() {")
			bb.Line(table.initials, ".", fk.CustomName, " = nil")
			bb.Line("}")

			if len(fk.ForeignKeys) > 0 {
				checkJoinFields(bb, table, fk.ForeignKeys)
			}
		}
	}
}

// TType template
func TType(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {

	bb.S("// GENERATED BY CODEGEN. DO NOT EDIT.")
	bb.NewLine()
	bb.Line("const table"+table.title+"Offset = ", strconv.Itoa(table.id*conf.FieldsPerTable))
	bb.Line("// Table column names for usage in select or update statements.")
	bb.Line("const (")
	for _, f := range table.Fields {
		bb.Line(table.title + f.title + " = iota + table" + table.title + "Offset")
	}
	bb.Line(")")
	bb.NewLine()

	bb.S("var " + strings.ToLower(table.title) + "QueryFieldsAll = []string{")
	for i, f := range table.Fields {
		if i > 0 {
			bb.S(",")
		}
		bb.S(`"` + strings.ToLower(f.Name) + `"`)
	}
	bb.Line(`}`)
	bb.NewLine()

	bb.Line("// returns fields, that should be used.")
	bb.Func("", strings.ToLower(table.title)+"QueryFields")
	bb.FuncParams("colSet *bitset.BitSet")
	bb.FuncReturn("[]string")
	bb.Line("if colSet == nil {")
	bb.Line("return " + strings.ToLower(table.title) + "QueryFieldsAll")
	bb.Line("}")
	bb.NewLine()
	bb.Line("fields := []string{}")
	for _, f := range table.Fields {
		bb.Line("if colSet.Test(" + table.title + f.title + ") {")
		bb.Line(`fields = append(fields, "` + strings.ToLower(f.Name) + `")`)
		bb.Line("}")
	}
	bb.Line("return fields")
	bb.FuncEnd()
	bb.NewLine()

	bb.Line("// ", table.title, " represents a row from '", schema.Name, ".", table.Name, "'.")

	bb.Struct(table.title)
	for _, f := range table.Fields {
		bb.Line(f.title, " ", f.goType, " `json:\"", f.Name, `" db:"`, strings.ToLower(f.Name), "\"`")
	}
	if len(table.ForeignKeys) > 0 {
		bb.NewLine()
	}
	fkVariable(bb, conf, table, table.ForeignKeys)
	bb.StructEnd()

	bb.Line("// Columns to be used for various statements.")
	bb.Func(table.storeReceiver, "Columns")
	bb.FuncParams("cols ...int")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, `.colSet = &bitset.BitSet{}
	for _, col := range cols {
		`, table.initials, `.colSet.Set(uint(col))
	}
	return `, table.initials)
	bb.FuncEnd()

	bb.Line("// IsEmpty checks if primary key fields are zero.")
	bb.Func(table.receiver, "IsEmpty")
	bb.FuncParams()
	bb.FuncReturn("bool")
	if len(table.pkFields) == 1 {
		bb.Line("return ", table.initials, ".", table.pkFields[0].title, " == ", table.pkFields[0].goZero)
	} else {
		for _, f := range table.pkFields {
			bb.Line("if ", table.initials, ".", f.title, " != ", f.goZero, " {")
			bb.Line("return false")
			bb.Line("}")
		}
		bb.Line("return true")
	}
	bb.FuncEnd()

	if len(table.ForeignKeys) > 0 {
		bb.Line("// checkJoinFields checks if join was successful and if not resets pointers to nil.")
		bb.Func(table.receiver, "checkJoinFields")
		bb.FuncParams()
		bb.FuncReturn()

		checkJoinFields(bb, table, table.ForeignKeys)

		bb.FuncEnd()
	}

	bb.Line("// ", table.store, " is used to query for '", table.title, "' records.")
	bb.Struct(table.store)
	bb.Line("db *sqlx.DB")
	bb.Line("withJoin bool")
	bb.Line("joinType string")
	bb.Line("where string")
	bb.Line("orderBy string")
	bb.Line("groupBy string")
	bb.Line("limit int")
	bb.Line("offset int")
	bb.Line("batch int")
	bb.Line("colSet *bitset.BitSet")
	bb.StructEnd()

	bb.Line("// New", table.title, "Store return DAO Store for ", table.title)
	bb.Func("", "New"+table.title+"Store")
	bb.FuncParams("conn *sqlx.DB")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, " := &", table.store, "{}")
	bb.Line(table.initials, ".db = conn")
	bb.Line(table.initials, ".withJoin = true")
	bb.Line(table.initials, `.joinType = sdb.LEFT`)
	bb.Line(table.initials, `.batch = 1000`)
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// WithoutJoins won't execute JOIN when querying for records.")
	bb.Func(table.storeReceiver, "WithoutJoins")
	bb.FuncParams()
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".withJoin = false")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// Where sets local sql, that will be appended to SELECT.")
	bb.Func(table.storeReceiver, "Where")
	bb.FuncParams("sql string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".where = sql")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// OrderBy sets local sql, that will be appended to SELECT.")
	bb.Func(table.storeReceiver, "OrderBy")
	bb.FuncParams("sql string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".orderBy = sql")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// GroupBy sets local sql, that will be appended to SELECT.")
	bb.Func(table.storeReceiver, "GroupBy")
	bb.FuncParams("sql string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".groupBy = sql")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// Limit result set size")
	bb.Func(table.storeReceiver, "Limit")
	bb.FuncParams("n int")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".limit = n")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// Offset used, if a limit is provided")
	bb.Func(table.storeReceiver, "Offset")
	bb.FuncParams("n int")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".offset = n")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	bb.Line("// JoinType sets join statement type (Default: INNER | LEFT | RIGHT | OUTER).")
	bb.Func(table.storeReceiver, "JoinType")
	bb.FuncParams("jt string")
	bb.FuncReturn("*" + table.store)
	bb.Line(table.initials, ".joinType = jt")
	bb.Line("return ", table.initials)
	bb.FuncEnd()

	/*
	   wird jetzt mittels bind gemacht
	   	// func fields
	   	bb.Func(table.receiver, "scanFields")
	   	bb.FuncParams("withJoin bool")
	   	bb.FuncReturn("[]interface{}")

	   	bb.Line("f := []interface{}{}")
	   	for _, f := range table.Fields {
	   		bb.Line("f = append(f, &", table.initials, ".", f.title, ")")
	   	}
	   	if len(table.ForeignKeys) > 0 {
	   		bb.Line("if withJoin {")
	   		for _, fk := range table.ForeignKeys {
	   			if fk.IsUnique {
	   				var fkRefTable *Table
	   				fkSchema := conf.getSchema(fk.RefSchema)
	   				if t := fkSchema.getTable(fk.RefTable); t != nil {
	   					fkRefTable = t
	   				}
	   				if fk.CustomName == "" {
	   					fk.CustomName = table.title + strings.Replace(fk.Name, "fk", "", 1)
	   				}

	   				for _, f := range fkRefTable.Fields {
	   					bb.Line("f = append(f, &", table.initials, ".", fk.CustomName, ".", f.title, ")")
	   				}

	   			}
	   		}
	   	}
	   	bb.Line("}")
	   	bb.Line("return f")
	   	bb.FuncEnd()
	*/

	bind(bb, conf, schema, table)
	selectSQL(bb, conf, schema, table)
	oneSelect(bb, conf, schema, table)
	querySelect(bb, conf, schema, table)
	queryCustom(bb, conf, schema, table)
}

func bindJoin(bb *GenBuffer, conf *Config, table *Table, fks []*ForeignKey) {
	for _, fk := range fks {
		if fk.IsUnique {
			var fkRefTable *Table
			fkSchema := conf.getSchema(fk.RefSchema)
			if t := fkSchema.getTable(fk.RefTable); t != nil {
				fkRefTable = t
			}
			if fk.CustomName == "" {
				fk.CustomName = table.title + strings.Replace(fk.Name, "fk", "", 1)
			}

			bb.Line(table.initials, ".", fk.CustomName, "= &", fkRefTable.title, "{}")
			bb.Line(table.initials, ".", fk.CustomName, ".bind(row, false, colSet, col)")

			if len(fk.ForeignKeys) > 0 {
				bindJoin(bb, conf, table, fk.ForeignKeys)
			}
		}
	}

}

func bind(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	// func fields
	bb.Func(table.receiver, "bind")
	bb.FuncParams("row []sql.RawBytes", "withJoin bool", "colSet *bitset.BitSet", "col *int")
	bb.FuncReturn()

	for i, f := range table.Fields {
		bb.Line("if colSet == nil || colSet.Test(", table.title+f.title, ") {")
		if f.mappingFunc != "" {
			bb.Line(table.initials, ".", f.title, " = ", f.mappingFunc, "(row[*col])")
		} else {
			bb.Line(table.initials, ".", f.title, " = row[*col]")
		}
		if i < table.numFields || len(table.ForeignKeys) > 0 {
			bb.Line("*col++")
		}
		bb.Line("}")
	}
	if len(table.ForeignKeys) > 0 {
		bb.Line("if withJoin {")
		bindJoin(bb, conf, table, table.ForeignKeys)
		bb.Line("}")
	}
	bb.FuncEnd()
}

func selectJoinFields(bb *GenBuffer, conf *Config, table *Table, tableAlias *rune, fks []*ForeignKey) {
	for _, fk := range fks {
		*tableAlias++
		if fk.IsUnique {
			fkRefTable := strings.Title(fk.RefTable)
			fkSchema := conf.getSchema(fk.RefSchema)
			if t := fkSchema.getTable(fk.RefTable); t != nil {
				fkRefTable = t.title
			}
			bb.Line(`sql.Fields(",","`, string(*tableAlias), `",`, strings.ToLower(fkRefTable), `QueryFields(`, table.initials, `.colSet))`)

			if len(fk.ForeignKeys) > 0 {
				selectJoinFields(bb, conf, table, tableAlias, fk.ForeignKeys)
			}
		}
	}
}

func selectJoinTable(bb *GenBuffer, conf *Config, table *Table, refAlias rune, tableAlias *rune, fks []*ForeignKey) {
	for _, fk := range fks {
		*tableAlias++
		if fk.IsUnique {
			fkSchema := conf.getSchema(fk.RefSchema)
			// TODO Join type
			bb.S(`sql.Append(`, table.initials, ".joinType", `," JOIN `, fkSchema.Name, ".", fk.RefTable, " ", string(*tableAlias), " ON (")
			for i, f := range fk.Fields {
				if i > 0 {
					bb.S(" AND ")
				}
				bb.S(string(refAlias), ".", f, " = ", string(*tableAlias), ".", fk.RefFields[i])
			}
			bb.Line(`)")`)

			if len(fk.ForeignKeys) > 0 {
				selectJoinTable(bb, conf, table, *tableAlias, tableAlias, fk.ForeignKeys)
			}
		}
	}
}

// selectSQL generates general SELECT Statement with optional JOINs based on foreign key definitions
func selectSQL(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Func(table.storeReceiver, "selectStatement")
	bb.FuncParams()
	bb.FuncReturn("*sdb.SQLStatement")

	tableAlias := 'A'
	bb.Line("sql := sdb.NewSQLStatement()")
	bb.Line(`sql.Append("SELECT")`)
	bb.Line(`sql.Fields("","`, string(tableAlias), `", `, strings.ToLower(table.title), `QueryFields(`, table.initials, `.colSet))`)
	bb.Line("if ", table.initials, ".withJoin {")
	{
		selectJoinFields(bb, conf, table, &tableAlias, table.ForeignKeys)
		bb.Line(`sql.Append("FROM `, schema.Name, ".", table.Name, ` A")`)
		tableAlias := 'A'
		selectJoinTable(bb, conf, table, 'A', &tableAlias, table.ForeignKeys)
	}
	bb.Line("} else {")
	{
		bb.Line(`sql.Append("FROM `, schema.Name, ".", table.Name, ` A")`)
	}
	bb.Line("}")

	bb.Line("if ", table.initials, `.where != "" {`)
	bb.Line(`sql.Append("WHERE", `, table.initials, ".where)")
	bb.Line("}")
	bb.Line("if ", table.initials, `.groupBy != "" {`)
	bb.Line(`sql.Append("GROUP BY", `, table.initials, ".groupBy)")
	bb.Line("}")
	bb.Line("if ", table.initials, `.orderBy != "" {`)
	bb.Line(`sql.Append("ORDER BY", `, table.initials, ".orderBy)")
	bb.Line("}")
	bb.Line("if ", table.initials, `.limit > 0 {`)
	bb.Line(`sql.AppendRaw("LIMIT ", `, table.initials, ".limit)")
	bb.Line("if ", table.initials, `.offset > 0 {`)
	bb.Line(`sql.AppendRaw(",", `, table.initials, ".offset)")
	bb.Line("}")
	bb.Line("}")
	bb.Line("return sql")
	bb.FuncEnd()
}

func oneSelect(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Line("// One retrieves a row from '", schema.Name, ".", table.Name, "' as a ", table.title, " with possible joined data.")
	bb.Func(table.storeReceiver, "One")
	bb.FuncParams("args ...interface{}")
	bb.FuncReturn("*"+table.title, "error")

	bb.Line("var err error")
	bb.Line("data := ", table.title, "{}")
	bb.NewLine()

	bb.Line("stmt := ", table.initials, ".selectStatement()")
	bb.Line(`if  zerolog.GlobalLevel() ==  zerolog.DebugLevel {`)
	bb.Line(`log.Debug().Str("fn", "`, table.store, `.One").Str("stmt", stmt.String()). Interface("args", args).Msg("sql")`)
	bb.Line("}")

	bb.Line("rows, err := ", table.initials, ".db.Query(stmt.Query(), args...)")
	bb.Line("if err != nil {")
	bb.Line("log.Error().Err(err).Msg(\"query\")")
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("defer rows.Close()")

	bb.Line("columns, err := rows.Columns()")
	bb.Line("if err != nil {")
	bb.Line(`log.Error().Err(err).Msg("columns")`)
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("values := make([]sql.RawBytes, len(columns))")
	bb.Line("scanArgs := make([]interface{}, len(values))")
	bb.Line("for i := range values {")
	bb.Line("scanArgs[i] = &values[i]")
	bb.Line("}")
	bb.Line("if rows.Next() {")
	bb.Line("err = rows.Scan(scanArgs...)")
	bb.Line("if err != nil {")
	bb.Line(`log.Error().Err(err).Msg("scan")`)
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("col := 0")
	bb.Line("data.bind(values, ", table.initials, ".withJoin, ", table.initials, ".colSet, &col)")

	if len(table.ForeignKeys) > 0 {
		bb.Line("if ", table.initials, ".withJoin {")
		bb.Line("data.checkJoinFields()")
		bb.Line("}")
	}
	bb.Line("} else {")
	bb.Line("return nil, sql.ErrNoRows")
	bb.Line("}")

	bb.Line("return &data, err")
	bb.FuncEnd()
}

func querySelect(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Line("// Query retrieves many rows from '", schema.Name, ".", table.Name, "' as a slice of ", table.title, " with possible joined data.")
	bb.Func(table.storeReceiver, "Query")
	bb.FuncParams("args ...interface{}")
	bb.FuncReturn("[]*"+table.title, "error")

	bb.Line("stmt := ", table.initials, ".selectStatement()")
	bb.Line("return ", table.initials, ".QueryCustom(stmt.Query(), args...)")
	bb.FuncEnd()
}

func queryCustom(bb *GenBuffer, conf *Config, schema *Schema, table *Table) {
	bb.Line("// QueryCustom retrieves many rows from '", schema.Name, ".", table.Name, "' as a slice of ", table.title, " with possible joined data.")
	bb.Func(table.storeReceiver, "QueryCustom")
	bb.FuncParams("stmt string", "args ...interface{}")
	bb.FuncReturn("[]*"+table.title, "error")

	bb.Line("var err error")
	bb.Line("res := []*", table.title, "{}")
	bb.NewLine()

	bb.Line(`if  zerolog.GlobalLevel() ==  zerolog.DebugLevel {`)
	bb.Line(`log.Debug().Str("fn", "`, table.store, `.Query").Str("stmt", stmt). Interface("args", args).Msg("sql")`)
	bb.Line("}")

	bb.Line("rows, err := ", table.initials, ".db.Query(stmt, args...)")
	bb.Line("if err != nil {")
	bb.Line(`log.Error().Err(err).Msg("query")`)
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("defer rows.Close()")

	bb.Line("columns, err := rows.Columns()")
	bb.Line("if err != nil {")
	bb.Line(`log.Error().Err(err).Msg("columns")`)
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("values := make([]sql.RawBytes, len(columns))")
	bb.Line("scanArgs := make([]interface{}, len(values))")
	bb.Line("for i := range values {")
	bb.Line("scanArgs[i] = &values[i]")
	bb.Line("}")
	bb.Line("for rows.Next() {")
	bb.Line("err = rows.Scan(scanArgs...)")
	bb.Line("if err != nil {")
	bb.Line(`log.Error().Err(err).Msg("scan")`)
	bb.Line("return nil, err")
	bb.Line("}")
	bb.Line("data := ", table.title, "{}")
	bb.Line("col := 0")
	bb.Line("data.bind(values, ", table.initials, ".withJoin, ", table.initials, ".colSet, &col)")

	if len(table.ForeignKeys) > 0 {
		bb.Line("if ", table.initials, ".withJoin {")
		bb.Line("data.checkJoinFields()")
		bb.Line("}")
	}
	bb.Line("res = append(res, &data)")
	bb.Line("}")

	bb.Line("return res, err")
	bb.FuncEnd()
}
