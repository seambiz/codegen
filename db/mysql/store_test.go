package mysql

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"math/big"
	"reflect"
	"testing"

	codegen "bitbucket.org/codegen"
	"github.com/DATA-DOG/go-sqlmock"
	"github.com/davecgh/go-spew/spew"
	"github.com/fatih/structs"
	"github.com/jmoiron/sqlx/reflectx"
	"github.com/rs/zerolog/log"
	"github.com/seambiz/seambiz/sdb"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// GENERATED BY CODEGEN. DO NOT EDIT.

// Insert inserts the Tables to the database.
func TestStoreMapScan(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	stmt := sdb.NewSQLStatement()
	stmt.Append("SELECT * FROM dummy.table")

	rows := sqlmock.NewRows([]string{"id", "col", "null"}).
		AddRow(1, "test", nil)
	mock.
		ExpectQuery("SELECT * FROM dummy.table").
		WillReturnRows(rows)

	res := map[string]sql.RawBytes{}
	err = NewStore(db).SQL(stmt.Query()).MapScan(res)
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	assert.Equal(t, 1, sdb.ToInt(res["id"]), "int")
	assert.Equal(t, "test", sdb.ToString(res["col"]), "string")
	assert.Nil(t, res["null"], "nil value")
}

// TestStoreSelfJoin just shows the specific use-case some code generators have problem with.
func TestStoreSelfJoin(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	rows := sqlmock.NewRows([]string{"id", "name", "id", "name"}).
		AddRow(1, "person", 2, "another person")
	mock.ExpectQuery("SELECT A.id, A.name , B.id, B.name FROM fake_benchmark.Person A INNER JOIN fake_benchmark B ON (A.id = B.id+1)").
		WillReturnRows(rows)

	store := NewStore(db).
		SelectFields("A", PersonQueryFields).
		SelectFields("B", PersonQueryFields).
		SQL("FROM fake_benchmark.Person A ").
		SQL("INNER JOIN fake_benchmark B ON (A.id = B.id+1)")
	var dest struct {
		codegen.Person
		Person2 struct {
			codegen.Person
		}
	}
	err = store.OneBind(&dest)
	assert.Nil(t, err)
	assert.Nil(t, mock.ExpectationsWereMet())

	assert.Equal(t, 1, dest.ID)
	assert.Equal(t, "person", dest.Name)
	assert.Equal(t, 2, dest.Person2.ID)
	assert.Equal(t, "another person", dest.Person2.Name)
}

// TestStoreOne shows the different functions to query for a single column.
func TestStoreOne(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	sql := sdb.NewSQLStatement()
	sql.Append("SELECT 1 FROM dummy.table")

	t.Run("OneInt", func(t *testing.T) {
		store := NewStore(db).SQL(sql.String())
		rows := sqlmock.NewRows([]string{"count"}).
			AddRow(1)

		mock.ExpectQuery("SELECT 1 FROM dummy.table").
			WillReturnRows(rows)
		res, err := store.OneInt()
		if err != nil {
			t.Fatalf("SQL error '%s'", err)
		}

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("there were unfulfilled expectations: %s", err)
		}
		assert.Equal(t, 1, res, "single int")
	})

	t.Run("OneString", func(t *testing.T) {
		store := NewStore(db).SQL(sql.String())
		rows := sqlmock.NewRows([]string{"count"}).
			AddRow(1)

		mock.ExpectQuery("SELECT 1 FROM dummy.table").
			WillReturnRows(rows)
		res, err := store.OneString()
		if err != nil {
			t.Fatalf("SQL error '%s'", err)
		}

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("there were unfulfilled expectations: %s", err)
		}
		assert.Equal(t, "1", res, "single string")
	})

	t.Run("OneBool", func(t *testing.T) {
		store := NewStore(db).SQL(sql.String())
		rows := sqlmock.NewRows([]string{"count"}).
			AddRow(1)

		mock.ExpectQuery("SELECT 1 FROM dummy.table").
			WillReturnRows(rows)
		res, err := store.OneBool()
		if err != nil {
			t.Fatalf("SQL error '%s'", err)
		}

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("there were unfulfilled expectations: %s", err)
		}
		assert.Equal(t, true, res, "single bool")
	})

	t.Run("OneValue", func(t *testing.T) {
		store := NewStore(db).SQL(sql.String())
		rows := sqlmock.NewRows([]string{"count"}).
			AddRow(1)

		mock.ExpectQuery("SELECT 1 FROM dummy.table").
			WillReturnRows(rows)
		res, err := store.OneValue(func(b []byte) interface{} {
			return sdb.ToInt64(b)
		})
		if err != nil {
			t.Fatalf("SQL error '%s'", err)
		}

		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("there were unfulfilled expectations: %s", err)
		}
		assert.Equal(t, int64(1), res, "single value")
	})
}

func prepareMockColumns(mock sqlmock.Sqlmock) {
	mock.
		ExpectQuery("SELECT A.id, A.species FROM fake_benchmark.pet A WHERE A.id = ?").
		WithArgs(1).
		WillReturnRows(sqlmock.NewRows([]string{"id", "species"}).
			AddRow(1, "cat"))
}

// TestStoreRawSQL show different methods to query for specific columns.
func TestStoreRawSQL(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	prepareMockColumns(mock)
	prepareMockColumns(mock)
	prepareMockColumns(mock)

	/**********************************************************************
	 * PetStore binding
	**********************************************************************/
	pet, err := NewPetStore(db).
		Columns(Pet_ID, Pet_Species).
		Where("A.id = ?").
		WithoutJoins().
		One(1)
	assert.Nil(t, err)
	assert.NotNil(t, pet)

	/**********************************************************************
	 * OnexInto (sqlx) binding
	**********************************************************************/
	petx := &codegen.Pet{}
	err = NewStore(db).
		SQL("SELECT A.id, A.species ").
		SQL("FROM fake_benchmark.pet A ").
		SQL("WHERE A.id = ?").
		OnexInto(petx, 1)
	assert.Nil(t, err)
	assert.NotNil(t, petx)

	/**********************************************************************
	 * Store general binding
	**********************************************************************/
	var petbase struct {
		codegen.Pet
	}
	err = NewStore(db).
		SelectFields("A", PetQueryFields, Pet_ID, Pet_Species).
		SQL("FROM fake_benchmark.pet A ").
		SQL("WHERE A.id = ?").
		OneBind(&petbase, 1)
	assert.Nil(t, err)
	assert.NotNil(t, petbase)

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}

	masterPet := &codegen.Pet{}
	masterPet.ID = 1
	masterPet.Species = "cat"

	assert.Equal(t, masterPet, pet, "petstore")
	assert.Equal(t, masterPet, petx, "store sqlx")
	assert.Equal(t, masterPet, &petbase.Pet, "store qrm")
}

func baseType(t reflect.Type, expected reflect.Kind) (reflect.Type, error) {
	t = reflectx.Deref(t)
	if t.Kind() != expected {
		return nil, fmt.Errorf("expected %s but got %s", expected, t.Kind())
	}
	return t, nil
}

// test helper
func testJoins(db *sql.DB, mock sqlmock.Sqlmock) *Store {
	mock.
		ExpectQuery("SELECT A.id, A.name , B.id, B.person_id, B.tag_id, B.species , C.id, C.name FROM fake_benchmark.person A INNER JOIN fake_benchmark.pet B ON (A.id = B.person_id) INNER JOIN fake_benchmark.tag C ON (B.tag_id = C.id) WHERE person.id = ?").
		WithArgs(1).
		WillReturnRows(sqlmock.NewRows([]string{"id", "name", "id", "person_id", "tag_id", "species", "id", "name"}).
			AddRow(1, "unknown", 1, 1, 1, "cat", 1, "one").
			AddRow(2, "unknown", 2, 2, 2, "dog", 2, "two").
			AddRow(3, "unknown", 3, 3, 2, "weasel", 2, "two"))

	return NewStore(db).
		SelectFields("A", PersonQueryFields).
		SelectFields("B", PetQueryFields).
		SelectFields("C", TagQueryFields).
		SQL("FROM fake_benchmark.person A ").
		SQL("INNER JOIN fake_benchmark.pet B ON (A.id = B.person_id) ").
		SQL("INNER JOIN fake_benchmark.tag C ON (B.tag_id = C.id) ").
		SQL("WHERE person.id = ?")
}

// test helper
func execScanToStruct(dest interface{}, t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	mock.
		ExpectQuery("SELECT A.id, A.name , B.id, B.person_id, B.tag_id, B.species , C.id, C.name FROM fake_benchmark.person A INNER JOIN fake_benchmark.pet B ON (A.id = B.person_id) INNER JOIN fake_benchmark.tag C ON (B.tag_id = C.id) WHERE person.id = ?").
		WithArgs(1).
		WillReturnRows(sqlmock.NewRows([]string{"id", "name", "id", "person_id", "tag_id", "species", "id", "name"}).
			AddRow(1, "unknown", 1, 1, 1, "cat", 1, "one"))

	err = NewStore(db).
		SelectFields("A", PersonQueryFields).
		SelectFields("B", PetQueryFields).
		SelectFields("C", TagQueryFields).
		SQL("FROM fake_benchmark.person A ").
		SQL("INNER JOIN fake_benchmark.pet B ON (A.id = B.person_id) ").
		SQL("INNER JOIN fake_benchmark.tag C ON (B.tag_id = C.id) ").
		SQL("WHERE person.id = ?").
		OneBind(dest, 1)

	require.Nil(t, err)
	assert.Nil(t, mock.ExpectationsWereMet())
}

func TestScanToStruct(t *testing.T) {
	tag1 := codegen.Tag{ID: 1, Name: "one"}
	person1 := codegen.Person{ID: 1, Name: "unknown"}
	pet1 := codegen.Pet{ID: 1, PersonID: 1, TagID: 1, Species: "cat"}

	t.Run("empy struct", func(t *testing.T) {
		var dest struct {
		}
		execScanToStruct(&dest, t)
	})
	t.Run("one struct", func(t *testing.T) {
		var dest struct {
			codegen.Person
		}
		execScanToStruct(&dest, t)

		assert.Equal(t, person1, dest.Person)
	})
	t.Run("all embedded", func(t *testing.T) {
		var dest struct {
			codegen.Person
			codegen.Pet
			codegen.Tag
		}
		execScanToStruct(&dest, t)

		assert.Equal(t, person1, dest.Person)
		assert.Equal(t, pet1, dest.Pet)
		assert.Equal(t, tag1, dest.Tag)
	})
	t.Run("ignore named structs", func(t *testing.T) {
		var dest struct {
			codegen.Person
			P2 codegen.Person
			codegen.Pet
			codegen.Tag
		}
		execScanToStruct(&dest, t)

		assert.Equal(t, person1, dest.Person)
		assert.Equal(t, pet1, dest.Pet)
		assert.Equal(t, tag1, dest.Tag)
	})
	t.Run("nested structs 1", func(t *testing.T) {
		var dest struct {
			codegen.Person
			Pet struct {
				codegen.Pet
			}
			codegen.Tag
		}
		execScanToStruct(&dest, t)

		assert.Equal(t, person1, dest.Person)
		assert.Equal(t, pet1, dest.Pet.Pet)
		assert.Equal(t, tag1, dest.Tag)
	})
	t.Run("nested structs 2", func(t *testing.T) {
		var dest struct {
			codegen.Person
			Pet struct {
				codegen.Pet
				codegen.Tag
			}
		}
		execScanToStruct(&dest, t)

		assert.Equal(t, person1, dest.Person)
		assert.Equal(t, pet1, dest.Pet.Pet)
		assert.Equal(t, tag1, dest.Pet.Tag)
	})
	t.Run("nested structs 3", func(t *testing.T) {
		var dest struct {
			codegen.Person
			Pet struct {
				codegen.Pet
				Tag struct {
					codegen.Tag
				}
			}
		}
		execScanToStruct(&dest, t)

		assert.Equal(t, person1, dest.Person)
		assert.Equal(t, pet1, dest.Pet.Pet)
		assert.Equal(t, tag1, dest.Pet.Tag.Tag)

		b, err := json.Marshal(dest)
		if err != nil {
			panic(err)
		}
		spew.Dump(string(b))
	})
}

func TestScanToSlice(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	tag1 := codegen.Tag{ID: 1, Name: "one"}
	tag2 := codegen.Tag{ID: 2, Name: "two"}

	person1 := codegen.Person{ID: 1, Name: "unknown"}
	person2 := codegen.Person{ID: 2, Name: "unknown"}
	person3 := codegen.Person{ID: 3, Name: "unknown"}

	pet1 := codegen.Pet{ID: 1, PersonID: 1, TagID: 1, Species: "cat"}
	pet2 := codegen.Pet{ID: 2, PersonID: 2, TagID: 2, Species: "dog"}
	pet3 := codegen.Pet{ID: 3, PersonID: 3, TagID: 2, Species: "weasel"}

	t.Run("all embedded", func(t *testing.T) {
		var dest []struct {
			codegen.Person
			codegen.Pet
			codegen.Tag
		}

		store := testJoins(db, mock)
		err = store.QueryBind(&dest, 1)
		assert.Nil(t, err)
		assert.Nil(t, mock.ExpectationsWereMet())

		assert.Equal(t, 3, len(dest))

		assert.Equal(t, person1, dest[0].Person)
		assert.Equal(t, pet1, dest[0].Pet)
		assert.Equal(t, tag1, dest[0].Tag)

		assert.Equal(t, person2, dest[1].Person)
		assert.Equal(t, pet2, dest[1].Pet)
		assert.Equal(t, tag2, dest[1].Tag)

		assert.Equal(t, person3, dest[2].Person)
		assert.Equal(t, pet3, dest[2].Pet)
		assert.Equal(t, tag2, dest[2].Tag)
	})

	t.Run("nested structs", func(t *testing.T) {
		var dest []struct {
			codegen.Person

			Pet struct {
				codegen.Pet
			}
			Tag struct {
				codegen.Tag
			}
		}

		store := testJoins(db, mock)
		err = store.QueryBind(&dest, 1)
		assert.Nil(t, err)
		assert.Nil(t, mock.ExpectationsWereMet())

		assert.Equal(t, 3, len(dest))

		assert.Equal(t, person1, dest[0].Person)
		assert.Equal(t, pet1, dest[0].Pet.Pet)
		assert.Equal(t, tag1, dest[0].Tag.Tag)

		assert.Equal(t, person2, dest[1].Person)
		assert.Equal(t, pet2, dest[1].Pet.Pet)
		assert.Equal(t, tag2, dest[1].Tag.Tag)

		assert.Equal(t, person3, dest[2].Person)
		assert.Equal(t, pet3, dest[2].Pet.Pet)
		assert.Equal(t, tag2, dest[2].Tag.Tag)
	})

	t.Run("nested structs 2", func(t *testing.T) {
		var dest []struct {
			codegen.Person

			Pet struct {
				codegen.Pet
				codegen.Tag
			}
		}

		store := testJoins(db, mock)
		err = store.QueryBind(&dest, 1)
		if err != nil {
			t.Fatalf("SQL error '%s'", err)
		}
		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("there were unfulfilled expectations: %s", err)
		}

		assert.Equal(t, 3, len(dest))

		assert.Equal(t, person1, dest[0].Person)
		assert.Equal(t, pet1, dest[0].Pet.Pet)
		assert.Equal(t, tag1, dest[0].Pet.Tag)

		assert.Equal(t, person2, dest[1].Person)
		assert.Equal(t, pet2, dest[1].Pet.Pet)
		assert.Equal(t, tag2, dest[1].Pet.Tag)

		assert.Equal(t, person3, dest[2].Person)
		assert.Equal(t, pet3, dest[2].Pet.Pet)
		assert.Equal(t, tag2, dest[2].Pet.Tag)
	})

	t.Run("nested structs 3", func(t *testing.T) {
		var dest []struct {
			codegen.Person

			Pet struct {
				codegen.Pet

				Tag struct {
					codegen.Tag
				}
			}
		}

		store := testJoins(db, mock)
		err = store.QueryBind(&dest, 1)
		if err != nil {
			t.Fatalf("SQL error '%s'", err)
		}
		if err := mock.ExpectationsWereMet(); err != nil {
			t.Errorf("there were unfulfilled expectations: %s", err)
		}

		assert.Equal(t, 3, len(dest))

		assert.Equal(t, person1, dest[0].Person)
		assert.Equal(t, pet1, dest[0].Pet.Pet)
		assert.Equal(t, tag1, dest[0].Pet.Tag.Tag)

		assert.Equal(t, person2, dest[1].Person)
		assert.Equal(t, pet2, dest[1].Pet.Pet)
		assert.Equal(t, tag2, dest[1].Pet.Tag.Tag)

		assert.Equal(t, person3, dest[2].Person)
		assert.Equal(t, pet3, dest[2].Pet.Pet)
		assert.Equal(t, tag2, dest[2].Pet.Tag.Tag)
	})
}

func (s *Store) SelectFields(tableAlias string, fieldFunc func(*big.Int) []string, columns ...int) *Store {
	if len(columns) > 0 {
		if s.colSet == nil {
			s.colSet = big.NewInt(0)
		}

		for _, col := range columns {
			s.colSet.SetBit(s.colSet, col, 1)
		}
	}

	if !s.selectCalled {
		s.stmt.AppendStr("SELECT ")
		s.selectCalled = true
	}

	s.stmt.Fields(s.prependField, tableAlias, fieldFunc(s.colSet))
	s.prependField = ", "

	s.stmt.AppendStr(" ")

	return s
}

func (s *Store) rowToSlice(dest interface{}, values []sql.RawBytes, col *int) error {
	value := reflect.ValueOf(dest)

	if value.Kind() != reflect.Ptr {
		panic("must pass a pointer, not a value, to StructScan destination")
	}
	if value.IsNil() {
		panic("nil pointer passed to StructScan destination")
	}
	var direct reflect.Value
	if value.Kind() == reflect.Struct {
		tempSlicePtrValue := reflect.New(reflect.SliceOf(value.Type()))
		tempSliceValue := tempSlicePtrValue.Elem()
		direct = reflect.Indirect(tempSliceValue)
	} else {
		direct = reflect.Indirect(value)
	}

	slice, err := baseType(value.Type(), reflect.Slice)
	if err != nil {
		return err
	}

	if direct.Kind() != reflect.Slice {
		panic("must pass a pointer to a slice")
	}

	slice, err = baseType(value.Type(), reflect.Slice)
	if err != nil {
		panic(err)
	}

	base := reflectx.Deref(slice.Elem())
	vp := reflect.New(base)
	v := reflect.Indirect(vp)

	s.mapRowToStruct(v, values, col)

	direct.Set(reflect.Append(direct, v))

	// spew.Dump("final", dest)

	return nil
}

func (s *Store) mapRowToStruct(pStruct reflect.Value, values []sql.RawBytes, col *int) error {
	baseType := pStruct.Type()

	for i := 0; i < pStruct.NumField(); i++ {
		field := pStruct.Field(i)

		switch field.Kind() {
		case reflect.Struct:
			fType := baseType.Field(i)
			if fType.Anonymous {
				switch field.Type().String() {
				case "codegen.Person":
					data, ok := field.Interface().(codegen.Person)
					if !ok {
						return errors.New("not ptr person")
					}
					BindFakeBenchmarkPerson(&data, values, false, s.colSet, col)
					field.Set(reflect.ValueOf(data))
				case "codegen.Pet":
					data, ok := field.Interface().(codegen.Pet)
					if !ok {
						return errors.New("not ptr pet")
					}
					BindFakeBenchmarkPet(&data, values, false, s.colSet, col)
					field.Set(reflect.ValueOf(data))
				case "codegen.Tag":
					data, ok := field.Interface().(codegen.Tag)
					if !ok {
						return errors.New("not ptr Tag")
					}
					BindFakeBenchmarkTag(&data, values, false, s.colSet, col)
					field.Set(reflect.ValueOf(data))
				}
			} else {
				s.mapRowToStruct(field, values, col)
			}
		case reflect.Slice:

		default:
			return errors.New("only structs and slices allowed")
		}
	}
	return nil
}

func (s *Store) QueryBind(dest interface{}, args ...interface{}) error {
	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	col := 0
	for rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
		col = 0
		err = s.rowToSlice(dest, values, &col)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

func (s *Store) OneBind(dest interface{}, args ...interface{}) error {
	value := reflect.ValueOf(dest)
	if value.Kind() != reflect.Ptr {
		panic("must pass a pointer, not a value, to StructScan destination")
	}
	if value.IsNil() {
		panic("nil pointer passed to StructScan destination")
	}
	direct := reflect.Indirect(value)

	rows, values, valuePointers, err := s.queryBegin(s.stmt.Query(), args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	col := 0
	if rows.Next() {
		err = rows.Scan(valuePointers...)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
		col = 0
		err = s.mapRowToStruct(direct, values, &col)
		if err != nil {
			log.Error().Err(err).Msg("scan")
			return err
		}
	} else {
		return sql.ErrNoRows
	}
	if err := rows.Close(); err != nil {
		return err
	}
	if err := rows.Err(); err != nil {
		return err
	}

	return nil
}

// ColumnsByStruct convinience function
func ColumnsByStruct(v interface{}) string {
	ret := ""

	for i, f := range structs.New(v).Fields() {
		if i > 0 {
			ret += ", "
		}
		tag := f.Tag("db")
		switch tag {
		case "-":
			continue
		case "":
			ret += f.Name()
		default:
			ret += tag
		}
	}
	return ret
}

/*
TODO: this is being used!!!

selecting columns
- using constants for normal fields
- using tags for mapping or name = struct field (like sqlx)
- handle aggregates or some other computation
- * not advised because of DB migrations

joins
- 1:1 join
- 1:N join


func (r *ItemRepository) QueryByOrder(companyID int, orderID int) ([]*kanban.Item, error) {
	items := []*kanban.Item{}

	sql := sdb.NewSQLStatement()
	sql.Append("SELECT I.* ")
	sql.Append("FROM", fmt.Sprintf("now%05d", companyID)+".item I")
	sql.Append("INNER JOIN", fmt.Sprintf("now%05d", companyID)+".order_detail OD ON (I.id = OD.item_id)")
	sql.Append("WHERE OD.order_id = ?")

	err := NewStore(r.db).SQL(sql.Query()).Select(&items, orderID)
	return items, err
}


*/

// func TestRawSQL(t *testing.T) {

// 	NewPetStore(conn Execer)

// 	err := NewStore(DB).
// 		Select("A.*, B.*").
// 		From("best.bestellung A").
// 		LeftJoin("best.bestelldetails B", "A.id = B.bestellung_id").
// 		Where("A.id = 1").
// 		Limit(1).
// 		Bind(b, d).
// 		One()
// 	if err != nil {
// 		t.Error(err)
// 	}

// 	bestellung, err := NewBestellungStore(DB).WithoutJoins().Where("A.id = 1").One()
// 	if err != nil {
// 		t.Error(err)
// 	}

// 	bestelldetails, err := NewBestelldetailsStore(DB).WithoutJoins().Where("A.bestellung_id = 1").One()
// 	if err != nil {
// 		t.Error(err)
// 	}

// 	if !reflect.DeepEqual(b, bestellung) {
// 		t.Error("\nExpected:", spew.Sdump(b), "\nReceived: ", spew.Sdump(bestellung))
// 	}

// 	if !reflect.DeepEqual(d, bestelldetails) {
// 		t.Error("\nExpected:", spew.Sdump(d), "\nReceived: ", spew.Sdump(bestelldetails))
// 	}

// 	if diff := deep.Equal(b, bestellung); diff != nil {
// 		t.Error(diff)
// 	}

// 	if diff := deep.Equal(d, bestelldetails); diff != nil {
// 		t.Error(diff)
// 	}
// }
