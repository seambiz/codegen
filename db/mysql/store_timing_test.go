package mysql

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"strconv"
	"testing"
	"unsafe"

	"github.com/brianvoe/gofakeit/v5"
	"github.com/rs/zerolog"
	codegen "github.com/seambiz/codegen"
	"github.com/seambiz/seambiz/sdb"
	"github.com/seambiz/seambiz/stime"
)

// GENERATED BY CODEGEN. 

type TimeSec5 struct{}

// Match satisfies sqlmock.Argument interface
func (a TimeSec5) Match(v driver.Value) bool {
	switch i := v.(type) {
	case int64:
		if int64(stime.Now())-i > 5 {
			return false
		}
	default:
		return false
	}
	return true
}

func init() {
	zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	gofakeit.Seed(1)
}

func insertQuery() (*sql.DB, error) {
	newResultDSN("bench", QueryResult{
		ResultRows: &ResultRows{
			NumRows: 1,
		},
		NumInput: -1,
	})
	return sql.Open("mimic", "bench")
}

func selectQuery(cols []string) (*sql.DB, error) {
	newResultDSN("bench", QueryResult{
		Query: &Query{
			Cols: cols,
			Vals: [][]driver.Value{},
		},
	})
	return sql.Open("mimic", "bench")
}

// ^^ END OF GENERATED BY CODEGEN. ^^

func BenchmarkOne(b *testing.B) {
	b.ReportAllocs()

	newResultDSN("bench", QueryResult{
		Query: &Query{
			Cols: []string{"pet.id", "pet.person_id", "pet.tag_id", "pet.species", "person.id", "person.name", "tag.id", "tag.name"},
			Vals: [][]driver.Value{},
		},
		NumInput: 1,
	})
	addResultRowDSN("bench", []driver.Value{1, 2, 3, "cat", 4, "name", 5, "tag"})

	db, err := sql.Open("mimic", "bench")
	if err != nil {
		b.Fatal(err)
	}
	defer db.Close()

	b.Run("petstore", func(b *testing.B) {
		store := NewPetStore(db)
		for i := 0; i < b.N; i++ {
			_, err := store.One(1)
			if err != nil {
				b.Fatal(err)
			}
		}
	})

	b.Run("store", func(b *testing.B) {
		store := NewStore(db).
			SelectFields("A", PetQueryFields).
			SelectFields("B", PersonQueryFields).
			SelectFields("C", TagQueryFields).
			SQL("FROM fake_benchmark.pet A ").
			SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
			SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
			SQL("WHERE A.id = ?")
		for i := 0; i < b.N; i++ {
			var dest struct {
				codegen.Pet
				codegen.Person
				codegen.Tag
			}
			err := store.OneBind(&dest, 1)
			if err != nil {
				b.Fatal(err)
			}
		}
	})

	b.Run("onex", func(b *testing.B) {
		store := NewStore(db).
			SelectFields("A", PetQueryFields).
			SelectFields("B", PersonQueryFields).
			SelectFields("C", TagQueryFields).
			SQL("FROM fake_benchmark.pet A ").
			SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
			SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
			SQL("WHERE A.id = ?")
		for i := 0; i < b.N; i++ {
			var dest struct {
				ID          int    `json:"id" db:"pet.id"`
				PetPersonID int    `json:"pet_person_id" db:"pet.person_id"`
				PetTagID    int    `json:"pet_tag_id" db:"pet.tag_id"`
				Species     string `json:"species" db:"pet.species"`

				PersonID   int    `json:"person_id" db:"person.id"`
				PersonName string `json:"name" db:"person.name"`

				TagID   int    `json:"tag_id" db:"tag.id"`
				TagName string `json:"tag_name" db:"tag.name"`
			}
			err := store.OnexInto(&dest, 1)
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

func BenchmarkEagerFetch(b *testing.B) {
	b.ReportAllocs()

	newResultDSN("bench", QueryResult{
		Query: &Query{
			Cols: []string{"pet.id", "pet.person_id", "pet.tag_id", "pet.species", "person.id", "person.name", "tag.id", "tag.name"},
			Vals: [][]driver.Value{},
		},
	})
	for i := 0; i < 100; i++ {
		addResultRowDSN("bench", []driver.Value{1, 1, 3, "cat", 4, "name", 5, "tag"})
	}

	db, err := sql.Open("mimic", "bench")
	if err != nil {
		b.Fatal(err)
	}
	defer db.Close()

	b.Run("petstore", func(b *testing.B) {
		store := NewPersonStore(db)
		for i := 0; i < b.N; i++ {
			data, err := store.Query()
			if err != nil {
				b.Fatalf("SQL error '%s'", err)
			}
			err = store.EagerFetchPets(data)
			if err != nil {
				b.Fatalf("SQL error '%s'", err)
			}
			if len(data[0].Pets) != 100 {
				b.Fatal("person 1 should have 100 pets")
			}
		}
	})

	b.Run("store", func(b *testing.B) {
		store := NewStore(db).
			SelectFields("A", PetQueryFields).
			SelectFields("B", PersonQueryFields).
			SelectFields("C", TagQueryFields).
			SQL("FROM fake_benchmark.pet A ").
			SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
			SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
			SQL("WHERE A.id = ?")
		for i := 0; i < b.N; i++ {
			var dest []struct {
				codegen.Pet
				codegen.Person
				codegen.Tag
			}
			err := store.QueryBind(&dest)
			if err != nil {
				b.Fatal(err)
			}
		}
	})
}

func BenchmarkQuery(b *testing.B) {
	b.ReportAllocs()

	testCases := []struct {
		numRows int
	}{
		{1},
		{10},
		{100},
		{1000},
		{10000},
	}

	for _, testCase := range testCases {

		newResultDSN("bench", QueryResult{
			Query: &Query{
				Cols: []string{"pet.id", "pet.person_id", "pet.tag_id", "pet.species", "person.id", "person.name", "tag.id", "tag.name"},
				DBTypes: []string{
					"INT8",
					"INT8",
					"INT8",
					"VARCHAR",
					"INT8",
					"VARCHAR",
					"INT8",
					"VARCHAR",
				},
				Vals: [][]driver.Value{},
			},
		})

		db, err := sql.Open("mimic", "bench")
		if err != nil {
			b.Fatal(err)
		}
		defer db.Close()

		for i := 0; i < testCase.numRows; i++ {
			addResultRowDSN("bench", []driver.Value{1, 2, 3, "cat" + strconv.Itoa(i), 4, "name" + strconv.Itoa(i), 5, "tag" + strconv.Itoa(i)})
		}

		b.Run(fmt.Sprintf("petstore_%d", testCase.numRows), func(b *testing.B) {
			store := NewPetStore(db)
			for i := 0; i < b.N; i++ {
				dest, err := store.Query()
				if err != nil {
					b.Fatal(err)
				}
				if len(dest) != testCase.numRows {
					b.Fatal("not all rows returned", len(dest))
				}
				if dest[0].HasTag.Name != "tag0" {
					b.Fatal("tag name", dest[0].HasTag.Name)
				}
			}
		})

		b.Run(fmt.Sprintf("store_%d", testCase.numRows), func(b *testing.B) {
			store := NewStore(db).
				SelectFields("A", PetQueryFields).
				SelectFields("B", PersonQueryFields).
				SelectFields("C", TagQueryFields).
				SQL("FROM fake_benchmark.pet A ").
				SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
				SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
				SQL("WHERE A.id = ?")
			for i := 0; i < b.N; i++ {
				var dest []struct {
					codegen.Pet
					codegen.Person
					codegen.Tag
				}
				err := store.QueryBind(&dest)
				if err != nil {
					b.Fatal(err)
				}
				if len(dest) != testCase.numRows {
					b.Fatal("not all rows returned", len(dest))
				}
				if dest[0].Tag.Name != "tag0" {
					b.Fatal("tag name", dest[0].Tag.Name)
				}
			}
		})

		b.Run(fmt.Sprintf("queryx_%d", testCase.numRows), func(b *testing.B) {
			store := NewStore(db).
				SelectFields("A", PetQueryFields).
				SelectFields("B", PersonQueryFields).
				SelectFields("C", TagQueryFields).
				SQL("FROM fake_benchmark.pet A ").
				SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
				SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
				SQL("WHERE A.id = ?")
			for i := 0; i < b.N; i++ {
				var dest []struct {
					Pet    codegen.Pet
					Person codegen.Person
					Tag    codegen.Tag
				}
				err := store.QueryxInto(&dest)
				if err != nil {
					b.Fatal(err)
				}
				if len(dest) != testCase.numRows {
					b.Fatal("not all rows returned", len(dest))
				}
				if dest[0].Tag.Name != "tag0" {
					b.Fatal("tag name", dest[0].Tag.Name)
				}
			}
		})

		b.Run(fmt.Sprintf("jet_%d", testCase.numRows), func(b *testing.B) {
			type Pet struct {
				ID       int
				PersonID int
				TagID    int
				Species  string
			}
			type Person struct {
				ID   int
				Name string
			}
			type Tag struct {
				ID   int
				Name string
			}
			store := NewStore(db).
				SelectFields("A", PetQueryFields).
				SelectFields("B", PersonQueryFields).
				SelectFields("C", TagQueryFields).
				SQL("FROM fake_benchmark.pet A ").
				SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
				SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
				SQL("WHERE A.id = ?")
			for i := 0; i < b.N; i++ {
				var dest []struct {
					Pet    Pet
					Person Person
					Tag    Tag
				}
				err := store.QueryJet(&dest)
				if err != nil {
					b.Fatal(err)
				}
				if len(dest) != testCase.numRows {
					fmt.Printf("%#v\n", dest)
					b.Fatal("not all rows returned", len(dest))
				}
				if dest[0].Tag.Name != "tag0" {
					b.Fatal("tag name", dest[0].Tag.Name)
				}
			}
		})

		b.Run(fmt.Sprintf("godbsql_%d", testCase.numRows), func(b *testing.B) {
			store := NewStore(db).
				SelectFields("A", PetQueryFields).
				SelectFields("B", PersonQueryFields).
				SelectFields("C", TagQueryFields).
				SQL("FROM fake_benchmark.pet A ").
				SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
				SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
				SQL("WHERE A.id = ?")
			stmt := store.GetSQL()
			for i := 0; i < b.N; i++ {
				var dest []codegen.Pet
				var pet codegen.Pet

				rows, err := db.Query(stmt)
				if err != nil {
					b.Fatal(err)
				}
				defer rows.Close()
				for rows.Next() {
					pet.BelongsTo = &codegen.Person{}
					pet.HasTag = &codegen.Tag{}

					err := rows.Scan(&pet.ID, &pet.PersonID, &pet.TagID, &pet.Species, &pet.BelongsTo.ID, &pet.BelongsTo.Name,
						&pet.HasTag.ID, &pet.HasTag.Name)
					if err != nil {
						b.Fatal(err)
					}
					dest = append(dest, pet)
				}
				err = rows.Err()
				if err != nil {
					b.Fatal(err)
				}
				if len(dest) != testCase.numRows {
					b.Fatal("not all rows returned", len(dest))
				}
				if dest[0].HasTag.Name != "tag0" {
					b.Fatal("tag name", dest[0].HasTag.Name)
				}
			}
		})

		b.Run(fmt.Sprintf("preparedsql_%d", testCase.numRows), func(b *testing.B) {
			store := NewStore(db).
				SelectFields("A", PetQueryFields).
				SelectFields("B", PersonQueryFields).
				SelectFields("C", TagQueryFields).
				SQL("FROM fake_benchmark.pet A ").
				SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
				SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
				SQL("WHERE A.id = ?")
			stmt := store.GetSQL()
			for i := 0; i < b.N; i++ {
				var dest []codegen.Pet
				var pet codegen.Pet

				prepared, err := db.Prepare(stmt)
				if err != nil {
					b.Fatal(err)
				}
				rows, err := prepared.Query()
				if err != nil {
					b.Fatal(err)
				}
				defer rows.Close()
				for rows.Next() {
					pet.BelongsTo = &codegen.Person{}
					pet.HasTag = &codegen.Tag{}

					err := rows.Scan(&pet.ID, &pet.PersonID, &pet.TagID, &pet.Species, &pet.BelongsTo.ID, &pet.BelongsTo.Name,
						&pet.HasTag.ID, &pet.HasTag.Name)
					if err != nil {
						b.Fatal(err)
					}
					dest = append(dest, pet)
				}
				err = rows.Err()
				if err != nil {
					b.Fatal(err)
				}
				if len(dest) != testCase.numRows {
					b.Fatal("not all rows returned", len(dest))
				}
				if dest[0].HasTag.Name != "tag0" {
					b.Fatal("tag name", dest[0].HasTag.Name)
				}
			}
		})

		b.Run(fmt.Sprintf("map_%d", testCase.numRows), func(b *testing.B) {
			store := NewStore(db).
				SelectFields("A", PetQueryFields).
				SelectFields("B", PersonQueryFields).
				SelectFields("C", TagQueryFields).
				SQL("FROM fake_benchmark.pet A ").
				SQL("INNER JOIN fake_benchmark.person B ON (A.person_id = B.id) ").
				SQL("INNER JOIN fake_benchmark.tag C ON (A.tag_id = C.id) ").
				SQL("WHERE A.id = ?")
			for i := 0; i < b.N; i++ {
				var dest []codegen.Pet
				var pet codegen.Pet

				err := store.Map(func(row []sql.RawBytes) {
					pet.ID = sdb.ToInt(row[0])
					pet.PersonID = sdb.ToInt(row[1])
					pet.TagID = sdb.ToInt(row[2])
					pet.Species = sdb.ToString(row[3])

					pet.BelongsTo = &codegen.Person{}
					pet.BelongsTo.ID = sdb.ToInt(row[4])
					pet.BelongsTo.Name = sdb.ToString(row[5])

					pet.HasTag = &codegen.Tag{}
					pet.HasTag.ID = sdb.ToInt(row[6])
					pet.HasTag.Name = sdb.ToString(row[7])
				}, func() {
					dest = append(dest, pet)
				})
				if err != nil {
					b.Fatal(err)
				}
				if len(dest) != testCase.numRows {
					b.Fatal("not all rows returned", len(dest))
				}
				if dest[0].HasTag.Name != "tag0" {
					b.Fatal("tag name", dest[0].HasTag.Name)
				}
			}
		})
	}
}

func b2s(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}
