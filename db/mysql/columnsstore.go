package mysql

import (
	"database/sql"
	"io"
	"math/big"

	codegen "github.com/seambiz/codegen"

	"github.com/seambiz/seambiz/sdb"
)

// GENERATED BY CODEGEN.

// COLUMNS represents a row from 'COLUMNS'.
type COLUMNS struct {
	codegen.COLUMNS
}

// new implements Bindable.new
func (s *COLUMNS) new() Bindable {
	return &COLUMNS{}
}

// helper struct for common query operations.
type COLUMNSSlice struct {
	data []*COLUMNS
}

// append implements BindableSlice.append
func (s *COLUMNSSlice) append(d Bindable) {
	s.data = append(s.data, d.(*COLUMNS))
}



// constant slice for all fields of the table "COLUMNS".
// nolint[gochecknoglobals]
var columnsQueryFieldsAll = []string{"table_catalog" , "table_schema" , "table_name" , "column_name" , "ordinal_position" , "column_default" , "is_nullable" , "data_type" , "character_maximum_length" , "character_octet_length" , "numeric_precision" , "numeric_scale" , "datetime_precision" , "character_set_name" , "collation_name" , "column_type" , "column_key" , "extra" , "privileges" , "column_comment" , "generation_expression"}

// returns fields, that should be used.
// nolint[gocyclo]
func COLUMNSQueryFields(colSet *big.Int) []string {
	if colSet == nil {
		return columnsQueryFieldsAll
	}

	fields := []string{}
    if colSet.Bit(codegen.COLUMNS_TABLECATALOG) == 1 {
		fields = append(fields, "table_catalog")
	}
	
    if colSet.Bit(codegen.COLUMNS_TABLESCHEMA) == 1 {
		fields = append(fields, "table_schema")
	}
	
    if colSet.Bit(codegen.COLUMNS_TABLENAME) == 1 {
		fields = append(fields, "table_name")
	}
	
    if colSet.Bit(codegen.COLUMNS_COLUMNNAME) == 1 {
		fields = append(fields, "column_name")
	}
	
    if colSet.Bit(codegen.COLUMNS_ORDINALPOSITION) == 1 {
		fields = append(fields, "ordinal_position")
	}
	
    if colSet.Bit(codegen.COLUMNS_COLUMNDEFAULT) == 1 {
		fields = append(fields, "column_default")
	}
	
    if colSet.Bit(codegen.COLUMNS_ISNULLABLE) == 1 {
		fields = append(fields, "is_nullable")
	}
	
    if colSet.Bit(codegen.COLUMNS_DATATYPE) == 1 {
		fields = append(fields, "data_type")
	}
	
    if colSet.Bit(codegen.COLUMNS_CHARACTERMAXIMUMLENGTH) == 1 {
		fields = append(fields, "character_maximum_length")
	}
	
    if colSet.Bit(codegen.COLUMNS_CHARACTEROCTETLENGTH) == 1 {
		fields = append(fields, "character_octet_length")
	}
	
    if colSet.Bit(codegen.COLUMNS_NUMERICPRECISION) == 1 {
		fields = append(fields, "numeric_precision")
	}
	
    if colSet.Bit(codegen.COLUMNS_NUMERICSCALE) == 1 {
		fields = append(fields, "numeric_scale")
	}
	
    if colSet.Bit(codegen.COLUMNS_DATETIMEPRECISION) == 1 {
		fields = append(fields, "datetime_precision")
	}
	
    if colSet.Bit(codegen.COLUMNS_CHARACTERSETNAME) == 1 {
		fields = append(fields, "character_set_name")
	}
	
    if colSet.Bit(codegen.COLUMNS_COLLATIONNAME) == 1 {
		fields = append(fields, "collation_name")
	}
	
    if colSet.Bit(codegen.COLUMNS_COLUMNTYPE) == 1 {
		fields = append(fields, "column_type")
	}
	
    if colSet.Bit(codegen.COLUMNS_COLUMNKEY) == 1 {
		fields = append(fields, "column_key")
	}
	
    if colSet.Bit(codegen.COLUMNS_EXTRA) == 1 {
		fields = append(fields, "extra")
	}
	
    if colSet.Bit(codegen.COLUMNS_PRIVILEGES) == 1 {
		fields = append(fields, "privileges")
	}
	
    if colSet.Bit(codegen.COLUMNS_COLUMNCOMMENT) == 1 {
		fields = append(fields, "column_comment")
	}
	
    if colSet.Bit(codegen.COLUMNS_GENERATIONEXPRESSION) == 1 {
		fields = append(fields, "generation_expression")
	}
	return fields
}
// COLUMNSStore is used to query for 'COLUMNS' records.
type COLUMNSStore struct {
	Store
	ctx *codegen.Context
}

// NewCOLUMNSStore return DAO Store for COLUMNS
func NewCOLUMNSStore(ctx *codegen.Context, conn Execer) *COLUMNSStore {
	s := &COLUMNSStore{}
	s.db = conn
	s.withJoin = true
	s.joinType = sdb.LEFT
	s.batch = 1000
	s.log = ctx.Log
	s.ctx = ctx
	return s
}

// WithoutJoins won't execute JOIN when querying for records.
func (s *COLUMNSStore) WithoutJoins() *COLUMNSStore {
	s.withJoin = false
	return s
}

// Where sets local sql, that will be appended to SELECT.
func (s *COLUMNSStore) Where(sql string) *COLUMNSStore {
	s.where = sql
	return s
}

// OrderBy sets local sql, that will be appended to SELECT.
func (s *COLUMNSStore) OrderBy(sql string) *COLUMNSStore {
	s.orderBy = sql
	return s
}

// GroupBy sets local sql, that will be appended to SELECT.
func (s *COLUMNSStore) GroupBy(sql string) *COLUMNSStore {
	s.groupBy = sql
	return s
}

// Limit result set size
func (s *COLUMNSStore) Limit(n int) *COLUMNSStore {
	s.limit = n
	return s
}

// Offset used, if a limit is provided
func (s *COLUMNSStore) Offset(n int) *COLUMNSStore {
	s.offset = n
	return s
}

// JoinType sets join statement type (Default: INNER | LEFT | RIGHT | OUTER).
func (s *COLUMNSStore) JoinType(jt string) *COLUMNSStore {
	s.joinType = jt
	return s
}

// Columns sets bits for specific columns.
func (s *COLUMNSStore) Columns(cols ...int) *COLUMNSStore {
	s.Store.Columns(cols...)
	return s
}

// SetBits sets complete BitSet for use in UpdatePartial.
func (s *COLUMNSStore) SetBits(colSet *big.Int) *COLUMNSStore {
	s.colSet = colSet
	return s
}
func (s *COLUMNS) bind(row []sql.RawBytes, withJoin bool, colSet *big.Int, col *int) {
    if colSet == nil || colSet.Bit(codegen.COLUMNS_TABLECATALOG) == 1 {
		s.TABLECATALOG = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_TABLESCHEMA) == 1 {
		s.TABLESCHEMA = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_TABLENAME) == 1 {
		s.TABLENAME = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_COLUMNNAME) == 1 {
		if row[*col] == nil {
			s.COLUMNNAME = nil
			} else {
				s.COLUMNNAME = new(string)
				*s.COLUMNNAME = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_ORDINALPOSITION) == 1 {
		s.ORDINALPOSITION = sdb.ToUInt(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_COLUMNDEFAULT) == 1 {
		if row[*col] == nil {
			s.COLUMNDEFAULT = nil
			} else {
				s.COLUMNDEFAULT = new(string)
				*s.COLUMNDEFAULT = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_ISNULLABLE) == 1 {
		s.ISNULLABLE = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_DATATYPE) == 1 {
		if row[*col] == nil {
			s.DATATYPE = nil
			} else {
				s.DATATYPE = new(string)
				*s.DATATYPE = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_CHARACTERMAXIMUMLENGTH) == 1 {
		if row[*col] == nil {
			s.CHARACTERMAXIMUMLENGTH = nil
			} else {
				s.CHARACTERMAXIMUMLENGTH = new(int64)
				*s.CHARACTERMAXIMUMLENGTH = sdb.ToInt64(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_CHARACTEROCTETLENGTH) == 1 {
		if row[*col] == nil {
			s.CHARACTEROCTETLENGTH = nil
			} else {
				s.CHARACTEROCTETLENGTH = new(int64)
				*s.CHARACTEROCTETLENGTH = sdb.ToInt64(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_NUMERICPRECISION) == 1 {
		if row[*col] == nil {
			s.NUMERICPRECISION = nil
			} else {
				s.NUMERICPRECISION = new(uint64)
				*s.NUMERICPRECISION = sdb.ToUInt64(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_NUMERICSCALE) == 1 {
		if row[*col] == nil {
			s.NUMERICSCALE = nil
			} else {
				s.NUMERICSCALE = new(uint64)
				*s.NUMERICSCALE = sdb.ToUInt64(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_DATETIMEPRECISION) == 1 {
		if row[*col] == nil {
			s.DATETIMEPRECISION = nil
			} else {
				s.DATETIMEPRECISION = new(uint)
				*s.DATETIMEPRECISION = sdb.ToUInt(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_CHARACTERSETNAME) == 1 {
		if row[*col] == nil {
			s.CHARACTERSETNAME = nil
			} else {
				s.CHARACTERSETNAME = new(string)
				*s.CHARACTERSETNAME = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_COLLATIONNAME) == 1 {
		if row[*col] == nil {
			s.COLLATIONNAME = nil
			} else {
				s.COLLATIONNAME = new(string)
				*s.COLLATIONNAME = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_COLUMNTYPE) == 1 {
		s.COLUMNTYPE = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_COLUMNKEY) == 1 {
		s.COLUMNKEY = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_EXTRA) == 1 {
		if row[*col] == nil {
			s.EXTRA = nil
			} else {
				s.EXTRA = new(string)
				*s.EXTRA = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_PRIVILEGES) == 1 {
		if row[*col] == nil {
			s.PRIVILEGES = nil
			} else {
				s.PRIVILEGES = new(string)
				*s.PRIVILEGES = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_COLUMNCOMMENT) == 1 {
		s.COLUMNCOMMENT = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.COLUMNS_GENERATIONEXPRESSION) == 1 {
		s.GENERATIONEXPRESSION = sdb.ToString(row[*col])
		*col++
	}}

func (s *COLUMNSStore) selectStatement() *sdb.SQLStatement {
	sql := sdb.NewSQLStatement()
	sql.Append("SELECT")
	sql.Fields("", "A", COLUMNSQueryFields(s.colSet))
			sql.Append(" FROM information_schema.COLUMNS A ")	
	if s.where != "" {
	    sql.Append("WHERE", s.where)
	}
	if s.groupBy != "" {
	    sql.Append("GROUP BY", s.groupBy)
	}
	if s.orderBy != "" {
	    sql.Append("ORDER BY", s.orderBy)
	}
	if s.limit > 0 {
	    sql.AppendRaw("LIMIT ", s.limit)
        if s.offset > 0 {
            sql.AppendRaw(",", s.offset)
        }
	}
	return sql
}
// QueryCustom retrieves many rows from 'information_schema.COLUMNS' as a slice of COLUMNS with 1:1 joined data.
func (s *COLUMNSStore) QueryCustom(stmt string, args ...interface{}) ([]*codegen.COLUMNS, error) {
    dto := &COLUMNS{}
    data := &COLUMNSSlice{}
    err := s.queryCustom(data, dto, stmt, args...)
    if err != nil {
        s.log.Error().Err(err).Msg("querycustom")
        return nil, err
    }
    retValues := make([]*codegen.COLUMNS, len(data.data))
    for i := range data.data {
        retValues[i] = &data.data[i].COLUMNS
    }
    return retValues, nil
}
// One retrieves a row from 'information_schema.COLUMNS' as a COLUMNS with 1:1 joined data.
func (s *COLUMNSStore) One(args ...interface{}) (*codegen.COLUMNS, error) {
    data := &COLUMNS{}

 	err := s.one(data, s.selectStatement(), args...)
	if err != nil {
        s.log.Error().Err(err).Msg("query one")
        return nil, err
	}
	return &data.COLUMNS, nil
}
// Query retrieves many rows from 'information_schema.COLUMNS' as a slice of COLUMNS with 1:1 joined data.
func (s *COLUMNSStore) Query(args ...interface{}) ([]*codegen.COLUMNS, error) {
	stmt := s.selectStatement()
	return s.QueryCustom(stmt.Query(), args...)
}



// cOLUMNSUpsertStmt helper for generating Upsert statement.
// nolint:gocyclo
func (s *COLUMNSStore) cOLUMNSUpsertStmt() *sdb.UpsertStatement {
	upsert := []string{}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLECATALOG) == 1 {
			    upsert = append(upsert, "table_catalog = VALUES(table_catalog)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLESCHEMA) == 1 {
			    upsert = append(upsert, "table_schema = VALUES(table_schema)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLENAME) == 1 {
			    upsert = append(upsert, "table_name = VALUES(table_name)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNNAME) == 1 {
			    upsert = append(upsert, "column_name = VALUES(column_name)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_ORDINALPOSITION) == 1 {
			    upsert = append(upsert, "ordinal_position = VALUES(ordinal_position)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNDEFAULT) == 1 {
			    upsert = append(upsert, "column_default = VALUES(column_default)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_ISNULLABLE) == 1 {
			    upsert = append(upsert, "is_nullable = VALUES(is_nullable)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_DATATYPE) == 1 {
			    upsert = append(upsert, "data_type = VALUES(data_type)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTERMAXIMUMLENGTH) == 1 {
			    upsert = append(upsert, "character_maximum_length = VALUES(character_maximum_length)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTEROCTETLENGTH) == 1 {
			    upsert = append(upsert, "character_octet_length = VALUES(character_octet_length)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_NUMERICPRECISION) == 1 {
			    upsert = append(upsert, "numeric_precision = VALUES(numeric_precision)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_NUMERICSCALE) == 1 {
			    upsert = append(upsert, "numeric_scale = VALUES(numeric_scale)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_DATETIMEPRECISION) == 1 {
			    upsert = append(upsert, "datetime_precision = VALUES(datetime_precision)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTERSETNAME) == 1 {
			    upsert = append(upsert, "character_set_name = VALUES(character_set_name)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLLATIONNAME) == 1 {
			    upsert = append(upsert, "collation_name = VALUES(collation_name)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNTYPE) == 1 {
			    upsert = append(upsert, "column_type = VALUES(column_type)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNKEY) == 1 {
			    upsert = append(upsert, "column_key = VALUES(column_key)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_EXTRA) == 1 {
			    upsert = append(upsert, "extra = VALUES(extra)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_PRIVILEGES) == 1 {
			    upsert = append(upsert, "privileges = VALUES(privileges)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNCOMMENT) == 1 {
			    upsert = append(upsert, "column_comment = VALUES(column_comment)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_GENERATIONEXPRESSION) == 1 {
			    upsert = append(upsert, "generation_expression = VALUES(generation_expression)")
			}
	sql := &sdb.UpsertStatement{}
		sql.InsertInto("information_schema.COLUMNS")
	sql.Columns("table_catalog","table_schema","table_name","column_name","ordinal_position","column_default","is_nullable","data_type","character_maximum_length","character_octet_length","numeric_precision","numeric_scale","datetime_precision","character_set_name","collation_name","column_type","column_key","extra","privileges","column_comment","generation_expression",)
    sql.OnDuplicateKeyUpdate(upsert)
	return sql	
}

// Upsert executes upsert for array of COLUMNS
func (s *COLUMNSStore) Upsert(data ...*codegen.COLUMNS) (int64, error) {
	sql := s.cOLUMNSUpsertStmt()
	
	for _, d := range data {
		sql.Record(d)
	}

	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "COLUMNSUpsert").Str("stmt", sql.String()).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query())
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return -1, err
	}
	affected, err := res.RowsAffected()
	if err != nil {
		s.log.Error().Err(err).Msg("rowsaffected")
		return -1, err
	}

	return affected, nil
}

// Insert inserts the COLUMNS to the database.
func (s *COLUMNSStore) Insert(data *codegen.COLUMNS) error {
    var err error
    sql := sdb.NewSQLStatement()
		sql.AppendRaw("INSERT INTO information_schema.COLUMNS (")
	fields := COLUMNSQueryFields(s.colSet)
	sql.Fields("", "", fields)
	sql.Append(") VALUES (")
	for i := range fields {
	    if i > 0 {
	        sql.Append(",")
	    }
	    sql.Append("?")
	}
	sql.Append(")")
	
	if s.log.Trace().Enabled() {
	    s.log.Trace().Str("fn", "information_schema.COLUMNS.Insert").Str("stmt", sql.String()).Str("TABLECATALOG", data.TABLECATALOG).Str("TABLESCHEMA", data.TABLESCHEMA).Str("TABLENAME", data.TABLENAME).Str("COLUMNNAME", logString(data.COLUMNNAME)).Uint("ORDINALPOSITION", data.ORDINALPOSITION).Str("COLUMNDEFAULT", logString(data.COLUMNDEFAULT)).Str("ISNULLABLE", data.ISNULLABLE).Str("DATATYPE", logString(data.DATATYPE)).Int64("CHARACTERMAXIMUMLENGTH", logInt64(data.CHARACTERMAXIMUMLENGTH)).Int64("CHARACTEROCTETLENGTH", logInt64(data.CHARACTEROCTETLENGTH)).Uint64("NUMERICPRECISION", logUInt64(data.NUMERICPRECISION)).Uint64("NUMERICSCALE", logUInt64(data.NUMERICSCALE)).Uint("DATETIMEPRECISION", logUInt(data.DATETIMEPRECISION)).Str("CHARACTERSETNAME", logString(data.CHARACTERSETNAME)).Str("COLLATIONNAME", logString(data.COLLATIONNAME)).Str("COLUMNTYPE", data.COLUMNTYPE).Str("COLUMNKEY", data.COLUMNKEY).Str("EXTRA", logString(data.EXTRA)).Str("PRIVILEGES", logString(data.PRIVILEGES)).Str("COLUMNCOMMENT", data.COLUMNCOMMENT).Str("GENERATIONEXPRESSION", data.GENERATIONEXPRESSION).Msg("sql")
    }
		_, err =s.db.Exec(sql.Query(),data.TABLECATALOG,data.TABLESCHEMA,data.TABLENAME,data.COLUMNNAME,data.ORDINALPOSITION,data.COLUMNDEFAULT,data.ISNULLABLE,data.DATATYPE,data.CHARACTERMAXIMUMLENGTH,data.CHARACTEROCTETLENGTH,data.NUMERICPRECISION,data.NUMERICSCALE,data.DATETIMEPRECISION,data.CHARACTERSETNAME,data.COLLATIONNAME,data.COLUMNTYPE,data.COLUMNKEY,data.EXTRA,data.PRIVILEGES,data.COLUMNCOMMENT,data.GENERATIONEXPRESSION)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return err
	}
	return nil
}

// Update updates the COLUMNS in the database.
// nolint[gocyclo]
func (s *COLUMNSStore) Update(data *codegen.COLUMNS) (int64, error) {
    sql := sdb.NewSQLStatement()
    var prepend string
    args := []interface{}{}
        sql.Append("UPDATE information_schema.COLUMNS SET")
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLECATALOG) == 1 {
            sql.AppendRaw(prepend, "table_catalog = ?")
                prepend = ","
            args = append(args, data.TABLECATALOG)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLESCHEMA) == 1 {
            sql.AppendRaw(prepend, "table_schema = ?")
                prepend = ","
            args = append(args, data.TABLESCHEMA)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLENAME) == 1 {
            sql.AppendRaw(prepend, "table_name = ?")
                prepend = ","
            args = append(args, data.TABLENAME)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNNAME) == 1 {
            sql.AppendRaw(prepend, "column_name = ?")
                prepend = ","
            args = append(args, data.COLUMNNAME)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_ORDINALPOSITION) == 1 {
            sql.AppendRaw(prepend, "ordinal_position = ?")
                prepend = ","
            args = append(args, data.ORDINALPOSITION)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNDEFAULT) == 1 {
            sql.AppendRaw(prepend, "column_default = ?")
                prepend = ","
            args = append(args, data.COLUMNDEFAULT)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_ISNULLABLE) == 1 {
            sql.AppendRaw(prepend, "is_nullable = ?")
                prepend = ","
            args = append(args, data.ISNULLABLE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_DATATYPE) == 1 {
            sql.AppendRaw(prepend, "data_type = ?")
                prepend = ","
            args = append(args, data.DATATYPE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTERMAXIMUMLENGTH) == 1 {
            sql.AppendRaw(prepend, "character_maximum_length = ?")
                prepend = ","
            args = append(args, data.CHARACTERMAXIMUMLENGTH)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTEROCTETLENGTH) == 1 {
            sql.AppendRaw(prepend, "character_octet_length = ?")
                prepend = ","
            args = append(args, data.CHARACTEROCTETLENGTH)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_NUMERICPRECISION) == 1 {
            sql.AppendRaw(prepend, "numeric_precision = ?")
                prepend = ","
            args = append(args, data.NUMERICPRECISION)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_NUMERICSCALE) == 1 {
            sql.AppendRaw(prepend, "numeric_scale = ?")
                prepend = ","
            args = append(args, data.NUMERICSCALE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_DATETIMEPRECISION) == 1 {
            sql.AppendRaw(prepend, "datetime_precision = ?")
                prepend = ","
            args = append(args, data.DATETIMEPRECISION)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTERSETNAME) == 1 {
            sql.AppendRaw(prepend, "character_set_name = ?")
                prepend = ","
            args = append(args, data.CHARACTERSETNAME)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLLATIONNAME) == 1 {
            sql.AppendRaw(prepend, "collation_name = ?")
                prepend = ","
            args = append(args, data.COLLATIONNAME)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNTYPE) == 1 {
            sql.AppendRaw(prepend, "column_type = ?")
                prepend = ","
            args = append(args, data.COLUMNTYPE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNKEY) == 1 {
            sql.AppendRaw(prepend, "column_key = ?")
                prepend = ","
            args = append(args, data.COLUMNKEY)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_EXTRA) == 1 {
            sql.AppendRaw(prepend, "extra = ?")
                prepend = ","
            args = append(args, data.EXTRA)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_PRIVILEGES) == 1 {
            sql.AppendRaw(prepend, "privileges = ?")
                prepend = ","
            args = append(args, data.PRIVILEGES)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNCOMMENT) == 1 {
            sql.AppendRaw(prepend, "column_comment = ?")
                prepend = ","
            args = append(args, data.COLUMNCOMMENT)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_GENERATIONEXPRESSION) == 1 {
            sql.AppendRaw(prepend, "generation_expression = ?")
            args = append(args, data.GENERATIONEXPRESSION)
        }
    sql.Append(" WHERE ")
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "information_schema.COLUMNS.Update").Str("stmt", sql.String()).Interface("args", args).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query(), args...)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return 0, err
	}
	return res.RowsAffected()
}
// Truncate deletes all rows from COLUMNS.
func (s *COLUMNSStore) Truncate() error {
	sql := sdb.NewSQLStatement()
		sql.Append("TRUNCATE information_schema.COLUMNS")
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "information_schema.COLUMNS.Truncate").Str("stmt", sql.String()).Msg("sql")
	}
	_, err := s.db.Exec(sql.Query())
	if err != nil {
	    s.log.Error().Err(err).Msg("exec")
	}
	return err
}



// ToJSON writes a single object to the buffer.
// nolint[gocylco]
func (s *COLUMNSStore) ToJSON(t *sdb.JsonBuffer, data *COLUMNS) {
	prepend := "{"
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLECATALOG) == 1 {
			t.JS(prepend, "table_catalog", data.TABLECATALOG)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLESCHEMA) == 1 {
			t.JS(prepend, "table_schema", data.TABLESCHEMA)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_TABLENAME) == 1 {
			t.JS(prepend, "table_name", data.TABLENAME)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNNAME) == 1 {
			t.JS(prepend, "column_name", *data.COLUMNNAME)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_ORDINALPOSITION) == 1 {
			t.JDu(prepend, "ordinal_position", data.ORDINALPOSITION)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNDEFAULT) == 1 {
			t.JS(prepend, "column_default", *data.COLUMNDEFAULT)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_ISNULLABLE) == 1 {
			t.JS(prepend, "is_nullable", data.ISNULLABLE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_DATATYPE) == 1 {
			t.JS(prepend, "data_type", *data.DATATYPE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTERMAXIMUMLENGTH) == 1 {
			t.JD64(prepend, "character_maximum_length", *data.CHARACTERMAXIMUMLENGTH)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTEROCTETLENGTH) == 1 {
			t.JD64(prepend, "character_octet_length", *data.CHARACTEROCTETLENGTH)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_NUMERICPRECISION) == 1 {
			t.JD64u(prepend, "numeric_precision", *data.NUMERICPRECISION)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_NUMERICSCALE) == 1 {
			t.JD64u(prepend, "numeric_scale", *data.NUMERICSCALE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_DATETIMEPRECISION) == 1 {
			t.JDu(prepend, "datetime_precision", *data.DATETIMEPRECISION)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_CHARACTERSETNAME) == 1 {
			t.JS(prepend, "character_set_name", *data.CHARACTERSETNAME)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLLATIONNAME) == 1 {
			t.JS(prepend, "collation_name", *data.COLLATIONNAME)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNTYPE) == 1 {
			t.JS(prepend, "column_type", data.COLUMNTYPE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNKEY) == 1 {
			t.JS(prepend, "column_key", data.COLUMNKEY)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_EXTRA) == 1 {
			t.JS(prepend, "extra", *data.EXTRA)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_PRIVILEGES) == 1 {
			t.JS(prepend, "privileges", *data.PRIVILEGES)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_COLUMNCOMMENT) == 1 {
			t.JS(prepend, "column_comment", data.COLUMNCOMMENT)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.COLUMNS_GENERATIONEXPRESSION) == 1 {
			t.JS(prepend, "generation_expression", data.GENERATIONEXPRESSION)
		}
	t.S(`}`)
}

// ToJSONArray writes a slice to the named array.
func (s *COLUMNSStore) ToJSONArray(w io.Writer, data []*COLUMNS, name string) {
	t := sdb.NewJsonBuffer()
	t.SS(`{"`, name, `":[`)
	for i := range data {
		if i > 0 {
			t.S(",")
		}
		s.ToJSON(t, data[i])
	}

	t.S("]}")
	_, err := w.Write(t.Bytes())
	if err != nil {
		panic(err)
	}
}
// ^^ END OF GENERATED BY CODEGEN. ^^
