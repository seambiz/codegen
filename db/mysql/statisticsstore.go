package mysql

import (
	"database/sql"
	"io"
	"math/big"

	codegen "github.com/seambiz/codegen"

	"github.com/seambiz/seambiz/sdb"
)

// GENERATED BY CODEGEN.

// STATISTICS represents a row from 'STATISTICS'.
type STATISTICS struct {
	codegen.STATISTICS
}

// new implements Bindable.new
func (s *STATISTICS) new() Bindable {
	return &STATISTICS{}
}

// helper struct for common query operations.
type STATISTICSSlice struct {
	data []*STATISTICS
}

// append implements BindableSlice.append
func (s *STATISTICSSlice) append(d Bindable) {
	s.data = append(s.data, d.(*STATISTICS))
}



// constant slice for all fields of the table "STATISTICS".
// nolint[gochecknoglobals]
var statisticsQueryFieldsAll = []string{"table_catalog" , "table_schema" , "table_name" , "non_unique" , "index_schema" , "index_name" , "seq_in_index" , "column_name" , "collation" , "cardinality" , "sub_part" , "packed" , "nullable" , "index_type" , "comment" , "index_comment" , "is_visible" , "expression"}

// returns fields, that should be used.
// nolint[gocyclo]
func STATISTICSQueryFields(colSet *big.Int) []string {
	if colSet == nil {
		return statisticsQueryFieldsAll
	}

	fields := []string{}
    if colSet.Bit(codegen.STATISTICS_TABLECATALOG) == 1 {
		fields = append(fields, "table_catalog")
	}
	
    if colSet.Bit(codegen.STATISTICS_TABLESCHEMA) == 1 {
		fields = append(fields, "table_schema")
	}
	
    if colSet.Bit(codegen.STATISTICS_TABLENAME) == 1 {
		fields = append(fields, "table_name")
	}
	
    if colSet.Bit(codegen.STATISTICS_NONUNIQUE) == 1 {
		fields = append(fields, "non_unique")
	}
	
    if colSet.Bit(codegen.STATISTICS_INDEXSCHEMA) == 1 {
		fields = append(fields, "index_schema")
	}
	
    if colSet.Bit(codegen.STATISTICS_INDEXNAME) == 1 {
		fields = append(fields, "index_name")
	}
	
    if colSet.Bit(codegen.STATISTICS_SEQININDEX) == 1 {
		fields = append(fields, "seq_in_index")
	}
	
    if colSet.Bit(codegen.STATISTICS_COLUMNNAME) == 1 {
		fields = append(fields, "column_name")
	}
	
    if colSet.Bit(codegen.STATISTICS_COLLATION) == 1 {
		fields = append(fields, "collation")
	}
	
    if colSet.Bit(codegen.STATISTICS_CARDINALITY) == 1 {
		fields = append(fields, "cardinality")
	}
	
    if colSet.Bit(codegen.STATISTICS_SUBPART) == 1 {
		fields = append(fields, "sub_part")
	}
	
    if colSet.Bit(codegen.STATISTICS_PACKED) == 1 {
		fields = append(fields, "packed")
	}
	
    if colSet.Bit(codegen.STATISTICS_NULLABLE) == 1 {
		fields = append(fields, "nullable")
	}
	
    if colSet.Bit(codegen.STATISTICS_INDEXTYPE) == 1 {
		fields = append(fields, "index_type")
	}
	
    if colSet.Bit(codegen.STATISTICS_COMMENT) == 1 {
		fields = append(fields, "comment")
	}
	
    if colSet.Bit(codegen.STATISTICS_INDEXCOMMENT) == 1 {
		fields = append(fields, "index_comment")
	}
	
    if colSet.Bit(codegen.STATISTICS_ISVISIBLE) == 1 {
		fields = append(fields, "is_visible")
	}
	
    if colSet.Bit(codegen.STATISTICS_EXPRESSION) == 1 {
		fields = append(fields, "expression")
	}
	return fields
}
// STATISTICSStore is used to query for 'STATISTICS' records.
type STATISTICSStore struct {
	Store
	ctx *codegen.Context
}

// NewSTATISTICSStore return DAO Store for STATISTICS
func NewSTATISTICSStore(ctx *codegen.Context, conn Execer) *STATISTICSStore {
	s := &STATISTICSStore{}
	s.db = conn
	s.withJoin = true
	s.joinType = sdb.LEFT
	s.batch = 1000
	s.log = ctx.Log
	s.ctx = ctx
	return s
}

// WithoutJoins won't execute JOIN when querying for records.
func (s *STATISTICSStore) WithoutJoins() *STATISTICSStore {
	s.withJoin = false
	return s
}

// Where sets local sql, that will be appended to SELECT.
func (s *STATISTICSStore) Where(sql string) *STATISTICSStore {
	s.where = sql
	return s
}

// OrderBy sets local sql, that will be appended to SELECT.
func (s *STATISTICSStore) OrderBy(sql string) *STATISTICSStore {
	s.orderBy = sql
	return s
}

// GroupBy sets local sql, that will be appended to SELECT.
func (s *STATISTICSStore) GroupBy(sql string) *STATISTICSStore {
	s.groupBy = sql
	return s
}

// Limit result set size
func (s *STATISTICSStore) Limit(n int) *STATISTICSStore {
	s.limit = n
	return s
}

// Offset used, if a limit is provided
func (s *STATISTICSStore) Offset(n int) *STATISTICSStore {
	s.offset = n
	return s
}

// JoinType sets join statement type (Default: INNER | LEFT | RIGHT | OUTER).
func (s *STATISTICSStore) JoinType(jt string) *STATISTICSStore {
	s.joinType = jt
	return s
}

// Columns sets bits for specific columns.
func (s *STATISTICSStore) Columns(cols ...int) *STATISTICSStore {
	s.Store.Columns(cols...)
	return s
}

// SetBits sets complete BitSet for use in UpdatePartial.
func (s *STATISTICSStore) SetBits(colSet *big.Int) *STATISTICSStore {
	s.colSet = colSet
	return s
}
func (s *STATISTICS) bind(row []sql.RawBytes, withJoin bool, colSet *big.Int, col *int) {
    if colSet == nil || colSet.Bit(codegen.STATISTICS_TABLECATALOG) == 1 {
		s.TABLECATALOG = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_TABLESCHEMA) == 1 {
		s.TABLESCHEMA = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_TABLENAME) == 1 {
		s.TABLENAME = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_NONUNIQUE) == 1 {
		s.NONUNIQUE = sdb.ToInt(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_INDEXSCHEMA) == 1 {
		s.INDEXSCHEMA = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_INDEXNAME) == 1 {
		if row[*col] == nil {
			s.INDEXNAME = nil
			} else {
				s.INDEXNAME = new(string)
				*s.INDEXNAME = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_SEQININDEX) == 1 {
		s.SEQININDEX = sdb.ToUInt(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_COLUMNNAME) == 1 {
		if row[*col] == nil {
			s.COLUMNNAME = nil
			} else {
				s.COLUMNNAME = new(string)
				*s.COLUMNNAME = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_COLLATION) == 1 {
		if row[*col] == nil {
			s.COLLATION = nil
			} else {
				s.COLLATION = new(string)
				*s.COLLATION = sdb.ToString(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_CARDINALITY) == 1 {
		if row[*col] == nil {
			s.CARDINALITY = nil
			} else {
				s.CARDINALITY = new(int64)
				*s.CARDINALITY = sdb.ToInt64(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_SUBPART) == 1 {
		if row[*col] == nil {
			s.SUBPART = nil
			} else {
				s.SUBPART = new(int64)
				*s.SUBPART = sdb.ToInt64(row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_PACKED) == 1 {
		if row[*col] == nil {
			s.PACKED = nil
			} else {
				s.PACKED = new([]byte)
				*s.PACKED = (row[*col])
			}
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_NULLABLE) == 1 {
		s.NULLABLE = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_INDEXTYPE) == 1 {
		s.INDEXTYPE = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_COMMENT) == 1 {
		s.COMMENT = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_INDEXCOMMENT) == 1 {
		s.INDEXCOMMENT = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_ISVISIBLE) == 1 {
		s.ISVISIBLE = sdb.ToString(row[*col])
		*col++
	}
    if colSet == nil || colSet.Bit(codegen.STATISTICS_EXPRESSION) == 1 {
		if row[*col] == nil {
			s.EXPRESSION = nil
			} else {
				s.EXPRESSION = new(string)
				*s.EXPRESSION = sdb.ToString(row[*col])
			}
		*col++
	}}

func (s *STATISTICSStore) selectStatement() *sdb.SQLStatement {
	sql := sdb.NewSQLStatement()
	sql.Append("SELECT")
	sql.Fields("", "A", STATISTICSQueryFields(s.colSet))
			sql.Append(" FROM information_schema.STATISTICS A ")	
	if s.where != "" {
	    sql.Append("WHERE", s.where)
	}
	if s.groupBy != "" {
	    sql.Append("GROUP BY", s.groupBy)
	}
	if s.orderBy != "" {
	    sql.Append("ORDER BY", s.orderBy)
	}
	if s.limit > 0 {
	    sql.AppendRaw("LIMIT ", s.limit)
        if s.offset > 0 {
            sql.AppendRaw(",", s.offset)
        }
	}
	return sql
}
// QueryCustom retrieves many rows from 'information_schema.STATISTICS' as a slice of STATISTICS with 1:1 joined data.
func (s *STATISTICSStore) QueryCustom(stmt string, args ...interface{}) ([]*codegen.STATISTICS, error) {
    dto := &STATISTICS{}
    data := &STATISTICSSlice{}
    err := s.queryCustom(data, dto, stmt, args...)
    if err != nil {
        s.log.Error().Err(err).Msg("querycustom")
        return nil, err
    }
    retValues := make([]*codegen.STATISTICS, len(data.data))
    for i := range data.data {
        retValues[i] = &data.data[i].STATISTICS
    }
    return retValues, nil
}
// One retrieves a row from 'information_schema.STATISTICS' as a STATISTICS with 1:1 joined data.
func (s *STATISTICSStore) One(args ...interface{}) (*codegen.STATISTICS, error) {
    data := &STATISTICS{}

 	err := s.one(data, s.selectStatement(), args...)
	if err != nil {
        s.log.Error().Err(err).Msg("query one")
        return nil, err
	}
	return &data.STATISTICS, nil
}
// Query retrieves many rows from 'information_schema.STATISTICS' as a slice of STATISTICS with 1:1 joined data.
func (s *STATISTICSStore) Query(args ...interface{}) ([]*codegen.STATISTICS, error) {
	stmt := s.selectStatement()
	return s.QueryCustom(stmt.Query(), args...)
}



// sTATISTICSUpsertStmt helper for generating Upsert statement.
// nolint:gocyclo
func (s *STATISTICSStore) sTATISTICSUpsertStmt() *sdb.UpsertStatement {
	upsert := []string{}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLECATALOG) == 1 {
			    upsert = append(upsert, "table_catalog = VALUES(table_catalog)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLESCHEMA) == 1 {
			    upsert = append(upsert, "table_schema = VALUES(table_schema)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLENAME) == 1 {
			    upsert = append(upsert, "table_name = VALUES(table_name)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_NONUNIQUE) == 1 {
			    upsert = append(upsert, "non_unique = VALUES(non_unique)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXSCHEMA) == 1 {
			    upsert = append(upsert, "index_schema = VALUES(index_schema)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXNAME) == 1 {
			    upsert = append(upsert, "index_name = VALUES(index_name)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_SEQININDEX) == 1 {
			    upsert = append(upsert, "seq_in_index = VALUES(seq_in_index)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COLUMNNAME) == 1 {
			    upsert = append(upsert, "column_name = VALUES(column_name)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COLLATION) == 1 {
			    upsert = append(upsert, "collation = VALUES(collation)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_CARDINALITY) == 1 {
			    upsert = append(upsert, "cardinality = VALUES(cardinality)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_SUBPART) == 1 {
			    upsert = append(upsert, "sub_part = VALUES(sub_part)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_PACKED) == 1 {
			    upsert = append(upsert, "packed = VALUES(packed)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_NULLABLE) == 1 {
			    upsert = append(upsert, "nullable = VALUES(nullable)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXTYPE) == 1 {
			    upsert = append(upsert, "index_type = VALUES(index_type)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COMMENT) == 1 {
			    upsert = append(upsert, "comment = VALUES(comment)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXCOMMENT) == 1 {
			    upsert = append(upsert, "index_comment = VALUES(index_comment)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_ISVISIBLE) == 1 {
			    upsert = append(upsert, "is_visible = VALUES(is_visible)")
			}
        	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_EXPRESSION) == 1 {
			    upsert = append(upsert, "expression = VALUES(expression)")
			}
	sql := &sdb.UpsertStatement{}
		sql.InsertInto("information_schema.STATISTICS")
	sql.Columns("table_catalog","table_schema","table_name","non_unique","index_schema","index_name","seq_in_index","column_name","collation","cardinality","sub_part","packed","nullable","index_type","comment","index_comment","is_visible","expression",)
    sql.OnDuplicateKeyUpdate(upsert)
	return sql	
}

// Upsert executes upsert for array of STATISTICS
func (s *STATISTICSStore) Upsert(data ...*codegen.STATISTICS) (int64, error) {
	sql := s.sTATISTICSUpsertStmt()
	
	for _, d := range data {
		sql.Record(d)
	}

	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "STATISTICSUpsert").Str("stmt", sql.String()).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query())
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return -1, err
	}
	affected, err := res.RowsAffected()
	if err != nil {
		s.log.Error().Err(err).Msg("rowsaffected")
		return -1, err
	}

	return affected, nil
}

// Insert inserts the STATISTICS to the database.
func (s *STATISTICSStore) Insert(data *codegen.STATISTICS) error {
    var err error
    sql := sdb.NewSQLStatement()
		sql.AppendRaw("INSERT INTO information_schema.STATISTICS (")
	fields := STATISTICSQueryFields(s.colSet)
	sql.Fields("", "", fields)
	sql.Append(") VALUES (")
	for i := range fields {
	    if i > 0 {
	        sql.Append(",")
	    }
	    sql.Append("?")
	}
	sql.Append(")")
	
	if s.log.Trace().Enabled() {
	    s.log.Trace().Str("fn", "information_schema.STATISTICS.Insert").Str("stmt", sql.String()).Str("TABLECATALOG", data.TABLECATALOG).Str("TABLESCHEMA", data.TABLESCHEMA).Str("TABLENAME", data.TABLENAME).Int("NONUNIQUE", data.NONUNIQUE).Str("INDEXSCHEMA", data.INDEXSCHEMA).Str("INDEXNAME", logString(data.INDEXNAME)).Uint("SEQININDEX", data.SEQININDEX).Str("COLUMNNAME", logString(data.COLUMNNAME)).Str("COLLATION", logString(data.COLLATION)).Int64("CARDINALITY", logInt64(data.CARDINALITY)).Int64("SUBPART", logInt64(data.SUBPART)).Bytes("PACKED", logBytes(data.PACKED)).Str("NULLABLE", data.NULLABLE).Str("INDEXTYPE", data.INDEXTYPE).Str("COMMENT", data.COMMENT).Str("INDEXCOMMENT", data.INDEXCOMMENT).Str("ISVISIBLE", data.ISVISIBLE).Str("EXPRESSION", logString(data.EXPRESSION)).Msg("sql")
    }
		_, err =s.db.Exec(sql.Query(),data.TABLECATALOG,data.TABLESCHEMA,data.TABLENAME,data.NONUNIQUE,data.INDEXSCHEMA,data.INDEXNAME,data.SEQININDEX,data.COLUMNNAME,data.COLLATION,data.CARDINALITY,data.SUBPART,data.PACKED,data.NULLABLE,data.INDEXTYPE,data.COMMENT,data.INDEXCOMMENT,data.ISVISIBLE,data.EXPRESSION)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return err
	}
	return nil
}

// Update updates the STATISTICS in the database.
// nolint[gocyclo]
func (s *STATISTICSStore) Update(data *codegen.STATISTICS) (int64, error) {
    sql := sdb.NewSQLStatement()
    var prepend string
    args := []interface{}{}
        sql.Append("UPDATE information_schema.STATISTICS SET")
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLECATALOG) == 1 {
            sql.AppendRaw(prepend, "table_catalog = ?")
                prepend = ","
            args = append(args, data.TABLECATALOG)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLESCHEMA) == 1 {
            sql.AppendRaw(prepend, "table_schema = ?")
                prepend = ","
            args = append(args, data.TABLESCHEMA)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLENAME) == 1 {
            sql.AppendRaw(prepend, "table_name = ?")
                prepend = ","
            args = append(args, data.TABLENAME)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_NONUNIQUE) == 1 {
            sql.AppendRaw(prepend, "non_unique = ?")
                prepend = ","
            args = append(args, data.NONUNIQUE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXSCHEMA) == 1 {
            sql.AppendRaw(prepend, "index_schema = ?")
                prepend = ","
            args = append(args, data.INDEXSCHEMA)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXNAME) == 1 {
            sql.AppendRaw(prepend, "index_name = ?")
                prepend = ","
            args = append(args, data.INDEXNAME)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_SEQININDEX) == 1 {
            sql.AppendRaw(prepend, "seq_in_index = ?")
                prepend = ","
            args = append(args, data.SEQININDEX)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COLUMNNAME) == 1 {
            sql.AppendRaw(prepend, "column_name = ?")
                prepend = ","
            args = append(args, data.COLUMNNAME)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COLLATION) == 1 {
            sql.AppendRaw(prepend, "collation = ?")
                prepend = ","
            args = append(args, data.COLLATION)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_CARDINALITY) == 1 {
            sql.AppendRaw(prepend, "cardinality = ?")
                prepend = ","
            args = append(args, data.CARDINALITY)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_SUBPART) == 1 {
            sql.AppendRaw(prepend, "sub_part = ?")
                prepend = ","
            args = append(args, data.SUBPART)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_PACKED) == 1 {
            sql.AppendRaw(prepend, "packed = ?")
                prepend = ","
            args = append(args, data.PACKED)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_NULLABLE) == 1 {
            sql.AppendRaw(prepend, "nullable = ?")
                prepend = ","
            args = append(args, data.NULLABLE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXTYPE) == 1 {
            sql.AppendRaw(prepend, "index_type = ?")
                prepend = ","
            args = append(args, data.INDEXTYPE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COMMENT) == 1 {
            sql.AppendRaw(prepend, "comment = ?")
                prepend = ","
            args = append(args, data.COMMENT)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXCOMMENT) == 1 {
            sql.AppendRaw(prepend, "index_comment = ?")
                prepend = ","
            args = append(args, data.INDEXCOMMENT)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_ISVISIBLE) == 1 {
            sql.AppendRaw(prepend, "is_visible = ?")
                prepend = ","
            args = append(args, data.ISVISIBLE)
        }
        if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_EXPRESSION) == 1 {
            sql.AppendRaw(prepend, "expression = ?")
            args = append(args, data.EXPRESSION)
        }
    sql.Append(" WHERE ")
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "information_schema.STATISTICS.Update").Str("stmt", sql.String()).Interface("args", args).Msg("sql")
	}
	res, err := s.db.Exec(sql.Query(), args...)
	if err != nil {
		s.log.Error().Err(err).Msg("exec")
		return 0, err
	}
	return res.RowsAffected()
}
// Truncate deletes all rows from STATISTICS.
func (s *STATISTICSStore) Truncate() error {
	sql := sdb.NewSQLStatement()
		sql.Append("TRUNCATE information_schema.STATISTICS")
	if s.log.Trace().Enabled() {
		s.log.Trace().Str("fn", "information_schema.STATISTICS.Truncate").Str("stmt", sql.String()).Msg("sql")
	}
	_, err := s.db.Exec(sql.Query())
	if err != nil {
	    s.log.Error().Err(err).Msg("exec")
	}
	return err
}



// ToJSON writes a single object to the buffer.
// nolint[gocylco]
func (s *STATISTICSStore) ToJSON(t *sdb.JsonBuffer, data *STATISTICS) {
	prepend := "{"
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLECATALOG) == 1 {
			t.JS(prepend, "table_catalog", data.TABLECATALOG)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLESCHEMA) == 1 {
			t.JS(prepend, "table_schema", data.TABLESCHEMA)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_TABLENAME) == 1 {
			t.JS(prepend, "table_name", data.TABLENAME)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_NONUNIQUE) == 1 {
			t.JD(prepend, "non_unique", data.NONUNIQUE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXSCHEMA) == 1 {
			t.JS(prepend, "index_schema", data.INDEXSCHEMA)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXNAME) == 1 {
			t.JS(prepend, "index_name", *data.INDEXNAME)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_SEQININDEX) == 1 {
			t.JDu(prepend, "seq_in_index", data.SEQININDEX)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COLUMNNAME) == 1 {
			t.JS(prepend, "column_name", *data.COLUMNNAME)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COLLATION) == 1 {
			t.JS(prepend, "collation", *data.COLLATION)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_CARDINALITY) == 1 {
			t.JD64(prepend, "cardinality", *data.CARDINALITY)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_SUBPART) == 1 {
			t.JD64(prepend, "sub_part", *data.SUBPART)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_PACKED) == 1 {
			t.JByte(prepend, "packed", *data.PACKED)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_NULLABLE) == 1 {
			t.JS(prepend, "nullable", data.NULLABLE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXTYPE) == 1 {
			t.JS(prepend, "index_type", data.INDEXTYPE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_COMMENT) == 1 {
			t.JS(prepend, "comment", data.COMMENT)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_INDEXCOMMENT) == 1 {
			t.JS(prepend, "index_comment", data.INDEXCOMMENT)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_ISVISIBLE) == 1 {
			t.JS(prepend, "is_visible", data.ISVISIBLE)
			prepend = ","
		}
	if s.colSet == nil || s.colSet.Bit(codegen.STATISTICS_EXPRESSION) == 1 {
			t.JS(prepend, "expression", *data.EXPRESSION)
		}
	t.S(`}`)
}

// ToJSONArray writes a slice to the named array.
func (s *STATISTICSStore) ToJSONArray(w io.Writer, data []*STATISTICS, name string) {
	t := sdb.NewJsonBuffer()
	t.SS(`{"`, name, `":[`)
	for i := range data {
		if i > 0 {
			t.S(",")
		}
		s.ToJSON(t, data[i])
	}

	t.S("]}")
	_, err := w.Write(t.Bytes())
	if err != nil {
		panic(err)
	}
}
// ^^ END OF GENERATED BY CODEGEN. ^^
