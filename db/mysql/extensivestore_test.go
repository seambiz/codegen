package mysql

import (
	"database/sql/driver"
	"reflect"
	"testing"
	"time"

	codegen "bitbucket.org/codegen"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/davecgh/go-spew/spew"
	"github.com/seambiz/seambiz/stime"
)

type TimeSec5 struct{}

// Match satisfies sqlmock.Argument interface
func (a TimeSec5) Match(v driver.Value) bool {
	spew.Dump(reflect.TypeOf(v))
	switch i := v.(type) {
	case int64:
		if int64(stime.Now())-i > 5 {
			return false
		}
	default:
		return false
	}
	return true
}

// GENERATED BY CODEGEN. DO NOT EDIT.

// Insert inserts the Extensive to the database.
func TestExtensiveInsert(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	mock.
		ExpectExec("INSERT INTO fake_benchmark.extensive ( id, tinyint, tinyint_unsigned, tinyint_null, smallint, smallint_unsigned, smallint_null, int, int_null, int_unsigned, bigint, bigint_null, bigint_unsigned, varchar, varchar_null, float, float_null, double, double_null, decimal, decimal_null, numeric, numeric_null, created_at, updated_at, tinyint1, tinyint1_null, year, year_null, date, date_null, time, time_null, datetime, datetime_null, timestamp, timestamp_null, char, char_null, tinytext, tinytext_null, text, text_null, mediumtext, mediumtext_null, longtext, longtext_null, binary, binary_null, varbinary, varbinary_null, tinyblob, tinyblob_null, blob, blob_null, mediumblob, mediumblob_null, longblob, longblob_null) VALUES ( ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? )").
		WithArgs(0, 0, 0, nil, 0, 0, nil, 0, nil, 0, 0, nil, 0, "", nil, 0.0, nil, 0.0, nil, 0.0, nil, 0.0, nil, TimeSec5{}, TimeSec5{}, false, nil, 0, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, "", nil, "", nil, "", nil, "", nil, "", nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil).
		WillReturnResult(sqlmock.NewResult(1, 1))

	store := NewExtensiveStore(db)
	err = store.Insert(&codegen.Extensive{})
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

func TestExtensiveUpdate(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	mock.
		ExpectExec("UPDATE fake_benchmark.extensive SET tinyint = ?,tinyint_unsigned = ?,tinyint_null = ?,smallint = ?,smallint_unsigned = ?,smallint_null = ?,int = ?,int_null = ?,int_unsigned = ?,bigint = ?,bigint_null = ?,bigint_unsigned = ?,varchar = ?,varchar_null = ?,float = ?,float_null = ?,double = ?,double_null = ?,decimal = ?,decimal_null = ?,numeric = ?,numeric_null = ?,created_at = ?,updated_at = ?,tinyint1 = ?,tinyint1_null = ?,year = ?,year_null = ?,date = ?,date_null = ?,time = ?,time_null = ?,datetime = ?,datetime_null = ?,timestamp = ?,timestamp_null = ?,char = ?,char_null = ?,tinytext = ?,tinytext_null = ?,text = ?,text_null = ?,mediumtext = ?,mediumtext_null = ?,longtext = ?,longtext_null = ?,binary = ?,binary_null = ?,varbinary = ?,varbinary_null = ?,tinyblob = ?,tinyblob_null = ?,blob = ?,blob_null = ?,mediumblob = ?,mediumblob_null = ?,longblob = ?,longblob_null = ? WHERE id = ?").
		WithArgs(0, 0, nil, 0, 0, nil, 0, nil, 0, 0, nil, 0, "", nil, 0.0, nil, 0.0, nil, 0.0, nil, 0.0, nil, 0, TimeSec5{}, false, nil, 0, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, "", nil, "", nil, "", nil, "", nil, "", nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, 0).
		WillReturnResult(sqlmock.NewResult(0, 1))

	store := NewExtensiveStore(db)
	aff, err := store.Update(&codegen.Extensive{})
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 1 {
		t.Errorf("a single row should be affected: %d", aff)
	}
}

func TestExtensiveSelectWithoutJoin(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	rows := sqlmock.NewRows([]string{"A.id", "A.tinyint", "A.tinyint_unsigned", "A.tinyint_null", "A.smallint", "A.smallint_unsigned", "A.smallint_null", "A.int", "A.int_null", "A.int_unsigned", "A.bigint", "A.bigint_null", "A.bigint_unsigned", "A.varchar", "A.varchar_null", "A.float", "A.float_null", "A.double", "A.double_null", "A.decimal", "A.decimal_null", "A.numeric", "A.numeric_null", "A.created_at", "A.updated_at", "A.tinyint1", "A.tinyint1_null", "A.year", "A.year_null", "A.date", "A.date_null", "A.time", "A.time_null", "A.datetime", "A.datetime_null", "A.timestamp", "A.timestamp_null", "A.char", "A.char_null", "A.tinytext", "A.tinytext_null", "A.text", "A.text_null", "A.mediumtext", "A.mediumtext_null", "A.longtext", "A.longtext_null", "A.binary", "A.binary_null", "A.varbinary", "A.varbinary_null", "A.tinyblob", "A.tinyblob_null", "A.blob", "A.blob_null", "A.mediumblob", "A.mediumblob_null", "A.longblob", "A.longblob_null"}).
		AddRow(0, 0, 0, nil, 0, 0, nil, 0, nil, 0, 0, nil, 0, "", nil, 0.0, nil, 0.0, nil, 0.0, nil, 0.0, nil, 0, 0, false, nil, 0, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, "", nil, "", nil, "", nil, "", nil, "", nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil).
		AddRow(0, 0, 0, nil, 0, 0, nil, 0, nil, 0, 0, nil, 0, "", nil, 0.0, nil, 0.0, nil, 0.0, nil, 0.0, nil, 0, 0, false, nil, 0, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, time.Time{}, nil, "", nil, "", nil, "", nil, "", nil, "", nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil, []byte(nil), nil)

	mock.ExpectQuery("SELECT A.id, A.tinyint, A.tinyint_unsigned, A.tinyint_null, A.smallint, A.smallint_unsigned, A.smallint_null, A.int, A.int_null, A.int_unsigned, A.bigint, A.bigint_null, A.bigint_unsigned, A.varchar, A.varchar_null, A.float, A.float_null, A.double, A.double_null, A.decimal, A.decimal_null, A.numeric, A.numeric_null, A.created_at, A.updated_at, A.tinyint1, A.tinyint1_null, A.year, A.year_null, A.date, A.date_null, A.time, A.time_null, A.datetime, A.datetime_null, A.timestamp, A.timestamp_null, A.char, A.char_null, A.tinytext, A.tinytext_null, A.text, A.text_null, A.mediumtext, A.mediumtext_null, A.longtext, A.longtext_null, A.binary, A.binary_null, A.varbinary, A.varbinary_null, A.tinyblob, A.tinyblob_null, A.blob, A.blob_null, A.mediumblob, A.mediumblob_null, A.longblob, A.longblob_null FROM fake_benchmark.extensive A").
		WillReturnRows(rows)

	store := NewExtensiveStore(db).WithoutJoins()
	data, err := store.Query()
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}

	if len(data) != 2 {
		t.Errorf("number of rows != 2: %d", len(data))
	}
}

func TestExtensiveDelete(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	mock.
		ExpectExec("DELETE FROM fake_benchmark.extensive WHERE id = ?").
		WithArgs(0).
		WillReturnResult(sqlmock.NewResult(0, 1))

	aff, err := NewExtensiveStore(db).Delete(&codegen.Extensive{})
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 1 {
		t.Errorf("a single row should be affected: %d", aff)
	}
}

func TestExtensiveDeleteSlice(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	mock.
		ExpectExec("DELETE FROM fake_benchmark.extensive WHERE id IN (0,0)").
		WillReturnResult(sqlmock.NewResult(0, 2))

	aff, err := NewExtensiveStore(db).DeleteSlice([]*codegen.Extensive{{}, {}})
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 2 {
		t.Errorf("two rows should be affected: %d", aff)
	}
}

/* TODO upsert needs some love. haven't used it for quite some time, but there are definitely some problems with a few data types. but they were not relevant for my previous usage.
func TestExtensiveUpsert(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()
	mock.
		ExpectExec("INSERT INTO fake_benchmark.extensive ( `id` , `tinyint` , `tinyint_unsigned` , `tinyint_null` , `smallint` , `smallint_unsigned` , `smallint_null` , `int` , `int_null` , `int_unsigned` , `bigint` , `bigint_null` , `bigint_unsigned` , `varchar` , `varchar_null` , `float` , `float_null` , `double` , `double_null` , `decimal` , `decimal_null` , `numeric` , `numeric_null` , `created_at` , `updated_at` , `tinyint1` , `tinyint1_null` , `year` , `year_null` , `date` , `date_null` , `time` , `time_null` , `datetime` , `datetime_null` , `timestamp` , `timestamp_null` , `char` , `char_null` , `tinytext` , `tinytext_null` , `text` , `text_null` , `mediumtext` , `mediumtext_null` , `longtext` , `longtext_null` , `binary` , `binary_null` , `varbinary` , `varbinary_null` , `tinyblob` , `tinyblob_null` , `blob` , `blob_null` , `mediumblob` , `mediumblob_null` , `longblob` , `longblob_null` ) VALUES ( '0' , '0' , '0' , NULL , '0' , '0' , NULL , '0' , NULL , '0' , '0' , NULL , '0' , '' , NULL , '0.0' , NULL , '0.0' , NULL , '0.0' , NULL , '0.0' , NULL , '0' , '0' , 'false' , NULL , '0' , NULL , 'time.Time{}' , NULL , 'time.Time{}' , NULL , 'time.Time{}' , NULL , 'time.Time{}' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL ), ( '0' , '0' , '0' , NULL , '0' , '0' , NULL , '0' , NULL , '0' , '0' , NULL , '0' , '' , NULL , '0.0' , NULL , '0.0' , NULL , '0.0' , NULL , '0.0' , NULL , '0' , '0' , 'false' , NULL , '0' , NULL , 'time.Time{}' , NULL , 'time.Time{}' , NULL , 'time.Time{}' , NULL , 'time.Time{}' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL , '' , NULL ) ON DUPLICATE KEY UPDATE tinyint = VALUES(tinyint),tinyint_unsigned = VALUES(tinyint_unsigned),tinyint_null = VALUES(tinyint_null),smallint = VALUES(smallint),smallint_unsigned = VALUES(smallint_unsigned),smallint_null = VALUES(smallint_null),int = VALUES(int),int_null = VALUES(int_null),int_unsigned = VALUES(int_unsigned),bigint = VALUES(bigint),bigint_null = VALUES(bigint_null),bigint_unsigned = VALUES(bigint_unsigned),varchar = VALUES(varchar),varchar_null = VALUES(varchar_null),float = VALUES(float),float_null = VALUES(float_null),double = VALUES(double),double_null = VALUES(double_null),decimal = VALUES(decimal),decimal_null = VALUES(decimal_null),numeric = VALUES(numeric),numeric_null = VALUES(numeric_null),created_at = VALUES(created_at),updated_at = VALUES(updated_at),tinyint1 = VALUES(tinyint1),tinyint1_null = VALUES(tinyint1_null),year = VALUES(year),year_null = VALUES(year_null),date = VALUES(date),date_null = VALUES(date_null),time = VALUES(time),time_null = VALUES(time_null),datetime = VALUES(datetime),datetime_null = VALUES(datetime_null),timestamp = VALUES(timestamp),timestamp_null = VALUES(timestamp_null),char = VALUES(char),char_null = VALUES(char_null),tinytext = VALUES(tinytext),tinytext_null = VALUES(tinytext_null),text = VALUES(text),text_null = VALUES(text_null),mediumtext = VALUES(mediumtext),mediumtext_null = VALUES(mediumtext_null),longtext = VALUES(longtext),longtext_null = VALUES(longtext_null),binary = VALUES(binary),binary_null = VALUES(binary_null),varbinary = VALUES(varbinary),varbinary_null = VALUES(varbinary_null),tinyblob = VALUES(tinyblob),tinyblob_null = VALUES(tinyblob_null),blob = VALUES(blob),blob_null = VALUES(blob_null),mediumblob = VALUES(mediumblob),mediumblob_null = VALUES(mediumblob_null),longblob = VALUES(longblob),longblob_null = VALUES(longblob_null)").
		WillReturnResult(sqlmock.NewResult(0, 2))

	aff, err := NewExtensiveStore(db).Upsert([]*codegen.Extensive{{}, {}}...)
	if err != nil {
		t.Fatalf("SQL error '%s'", err)
	}

	// we make sure that all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
	if aff != 2 {
		t.Errorf("two rows should be affected: %d", aff)
	}
}
*/
// ^^ END OF GENERATED BY CODEGEN. DO NOT EDIT. ^^
